/**
 * Generated by orval v7.14.0 üç∫
 * Do not edit manually.
 * Nutri AI Food Calorie Tracker API
 * API –¥–ª—è —É—á—ë—Ç–∞ –∏ –ø–æ–¥—Å—á—ë—Ç–∞ –∫–∞–ª–æ—Ä–∏–π —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –≤–≤–æ–¥–∞ –ø—Ä–∏—ë–º–∞ –ø–∏—â–∏ —á–µ—Ä–µ–∑ –ò–ò
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import { faker } from "@faker-js/faker";

import { HttpResponse, delay, http } from "msw";
import type { RequestHandlerOptions } from "msw";

import { createInstance } from "../api-instance";
import type { ErrorType, BodyType } from "../api-instance";
export interface User {
  id: string;
  email: string;
  passwordHash: string;
  displayName?: string;
  timezone?: string;
  /** @minimum 0 */
  dailyKcalGoal?: number;
  createdAt: string;
}

export interface DayEntry {
  id: string;
  userId: string;
  date: string;
  /** @minimum 0 */
  targetKcal?: number;
  /** @minimum 0 */
  consumedKcal?: number;
  notes?: string;
  createdAt: string;
  updatedAt: string;
  meals?: Meal[];
}

export type MealType = (typeof MealType)[keyof typeof MealType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MealType = {
  breakfast: "breakfast",
  lunch: "lunch",
  dinner: "dinner",
  snack: "snack",
  other: "other",
} as const;

export type MealSource = (typeof MealSource)[keyof typeof MealSource];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MealSource = {
  manual: "manual",
  ai: "ai",
} as const;

export interface Meal {
  id: string;
  dayEntryId: string;
  type: MealType;
  /** @pattern ^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$ */
  time?: string;
  name?: string;
  items?: FoodItem[];
  /** @minimum 0 */
  totalKcal: number;
  source: MealSource;
  /**
   * @minimum 0
   * @maximum 1
   */
  aiConfidence?: number;
  createdAt: string;
  updatedAt: string;
}

export interface FoodItem {
  id: string;
  mealId: string;
  /**
   * –°—Å—ã–ª–∫–∞ –Ω–∞ Product
   * @nullable
   */
  productId?: string | null;
  /**
   * –°—Å—ã–ª–∫–∞ –Ω–∞ Recipe
   * @nullable
   */
  recipeId?: string | null;
  name: string;
  /** –î–ª—è –ø—Ä–æ–¥—É–∫—Ç–∞ - –≥—Ä–∞–º–º—ã, –¥–ª—è —Ä–µ—Ü–µ–ø—Ç–∞ - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ä—Ü–∏–π */
  quantity: number;
  unit: string;
  /** @minimum 0 */
  kcal: number;
  protein?: number;
  fat?: number;
  carbs?: number;
  /** –û—Ç–∫—É–¥–∞ –≤–∑—è—Ç item (product, recipe, ai) */
  source?: string;
}

/**
 * –ò—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö
 */
export type ProductSource = (typeof ProductSource)[keyof typeof ProductSource];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProductSource = {
  manual: "manual",
  ai: "ai",
  openfoodfacts: "openfoodfacts",
  user: "user",
} as const;

export interface Product {
  id: string;
  name: string;
  /** –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ */
  normalizedName?: string;
  kcalPer100g: number;
  proteinPer100g?: number;
  fatPer100g?: number;
  carbsPer100g?: number;
  /** @nullable */
  fiberPer100g?: number | null;
  /** @nullable */
  sugarPer100g?: number | null;
  /** –ò—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö */
  source?: ProductSource;
  /** –ü—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–π –ø—Ä–æ–¥—É–∫—Ç */
  isVerified?: boolean;
  /** –°–∫–æ–ª—å–∫–æ —Ä–∞–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ */
  usageCount?: number;
  /**
   * ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ—Å–ª–∏ —Å–æ–∑–¥–∞–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
   * @nullable
   */
  createdBy?: string | null;
  /**
   * EAN/UPC —à—Ç—Ä–∏—Ö–∫–æ–¥
   * @nullable
   */
  barcode?: string | null;
  /** @nullable */
  brand?: string | null;
  /** @nullable */
  category?: string | null;
  createdAt: string;
  updatedAt?: string;
}

export type RecipeCategory =
  (typeof RecipeCategory)[keyof typeof RecipeCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecipeCategory = {
  breakfast: "breakfast",
  lunch: "lunch",
  dinner: "dinner",
  snack: "snack",
  dessert: "dessert",
  drink: "drink",
  other: "other",
} as const;

export interface Recipe {
  id: string;
  userId: string;
  name: string;
  description?: string;
  /**
   * –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ä—Ü–∏–π –≤ —Ä–µ—Ü–µ–ø—Ç–µ
   * @minimum 1
   */
  servings: number;
  category?: RecipeCategory;
  ingredients?: RecipeIngredient[];
  /** @minimum 0 */
  totalKcal?: number;
  totalProtein?: number;
  totalFat?: number;
  totalCarbs?: number;
  kcalPerServing?: number;
  proteinPerServing?: number;
  fatPerServing?: number;
  carbsPerServing?: number;
  /** @nullable */
  imageUrl?: string | null;
  /**
   * –í—Ä–µ–º—è –ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è –≤ –º–∏–Ω—É—Ç–∞—Ö
   * @nullable
   */
  cookingTime?: number | null;
  /** –°–∫–æ–ª—å–∫–æ —Ä–∞–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ */
  usageCount?: number;
  /** @nullable */
  lastUsedAt?: string | null;
  /** –ü–æ–¥–µ–ª–∏—Ç—å—Å—è —Å –¥—Ä—É–≥–∏–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ */
  isPublic?: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface RecipeIngredient {
  id?: string;
  recipeId?: string;
  /** –°—Å—ã–ª–∫–∞ –Ω–∞ Product */
  productId: string;
  /** –ó–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è */
  productName?: string;
  quantity: number;
  unit: string;
  kcal?: number;
  protein?: number;
  fat?: number;
  carbs?: number;
  /** @nullable */
  notes?: string | null;
}

export type DietPlanMacros = {
  proteinPct?: number;
  fatPct?: number;
  carbsPct?: number;
};

export interface DietPlan {
  id: string;
  /** @nullable */
  userId?: string | null;
  name: string;
  /** @minimum 0 */
  targetKcal: number;
  macros?: DietPlanMacros;
  description?: string;
  createdAt: string;
  updatedAt: string;
}

export type AiParseLogRequestPayload = { [key: string]: unknown };

export type AiParseLogResponsePayload = { [key: string]: unknown };

export interface AiParseLog {
  id: string;
  /** @nullable */
  userId?: string | null;
  requestText: string;
  requestPayload?: AiParseLogRequestPayload;
  responsePayload?: AiParseLogResponsePayload;
  responseTimeMs?: number;
  createdAt: string;
}

export interface CalendarDay {
  date: string;
  /** @minimum 0 */
  consumedKcal: number;
  /** @minimum 0 */
  targetKcal: number;
  /**
   * @minimum 0
   * @maximum 100
   */
  consumedPercent: number;
}

export interface SignupRequest {
  email: string;
  /** @minLength 8 */
  password: string;
  displayName?: string;
  timezone?: string;
}

export interface LoginRequest {
  email: string;
  password: string;
  timezone?: string;
}

export interface GoogleAuthRequest {
  /** Google ID token from Gmail OAuth */
  idToken: string;
  timezone?: string;
}

export interface AuthResponse {
  token?: string;
  user?: User;
}

export type CreateMealRequestType =
  (typeof CreateMealRequestType)[keyof typeof CreateMealRequestType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateMealRequestType = {
  breakfast: "breakfast",
  lunch: "lunch",
  dinner: "dinner",
  snack: "snack",
  other: "other",
} as const;

export type CreateMealRequestItemsItem = {
  /** @nullable */
  productId?: string | null;
  /** @nullable */
  recipeId?: string | null;
  quantity: number;
};

export type CreateMealRequestSource =
  (typeof CreateMealRequestSource)[keyof typeof CreateMealRequestSource];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateMealRequestSource = {
  manual: "manual",
  ai: "ai",
} as const;

export interface CreateMealRequest {
  type: CreateMealRequestType;
  /** @pattern ^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$ */
  time?: string;
  name?: string;
  items: CreateMealRequestItemsItem[];
  source: CreateMealRequestSource;
  /**
   * @minimum 0
   * @maximum 1
   * @nullable
   */
  aiConfidence?: number | null;
}

export type CreateProductRequestSource =
  (typeof CreateProductRequestSource)[keyof typeof CreateProductRequestSource];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateProductRequestSource = {
  manual: "manual",
  ai: "ai",
  openfoodfacts: "openfoodfacts",
} as const;

export interface CreateProductRequest {
  name: string;
  kcalPer100g: number;
  proteinPer100g?: number;
  fatPer100g?: number;
  carbsPer100g?: number;
  fiberPer100g?: number;
  sugarPer100g?: number;
  barcode?: string;
  brand?: string;
  category?: string;
  source?: CreateProductRequestSource;
}

export interface UpdateProductRequest {
  name?: string;
  kcalPer100g?: number;
  proteinPer100g?: number;
  fatPer100g?: number;
  carbsPer100g?: number;
  fiberPer100g?: number;
  sugarPer100g?: number;
  barcode?: string;
  brand?: string;
  category?: string;
}

export type CreateRecipeRequestCategory =
  (typeof CreateRecipeRequestCategory)[keyof typeof CreateRecipeRequestCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateRecipeRequestCategory = {
  breakfast: "breakfast",
  lunch: "lunch",
  dinner: "dinner",
  snack: "snack",
  dessert: "dessert",
  drink: "drink",
  other: "other",
} as const;

export type CreateRecipeRequestIngredientsItem = {
  productId: string;
  quantity: number;
  unit: string;
  notes?: string;
};

export interface CreateRecipeRequest {
  name: string;
  description?: string;
  /** @minimum 1 */
  servings: number;
  category?: CreateRecipeRequestCategory;
  ingredients: CreateRecipeRequestIngredientsItem[];
  cookingTime?: number;
  imageUrl?: string;
  isPublic?: boolean;
}

export type UpdateRecipeRequestIngredientsItem = {
  productId?: string;
  quantity?: number;
  unit?: string;
  notes?: string;
};

export interface UpdateRecipeRequest {
  name?: string;
  description?: string;
  /** @minimum 1 */
  servings?: number;
  category?: string;
  ingredients?: UpdateRecipeRequestIngredientsItem[];
  cookingTime?: number;
  imageUrl?: string;
  isPublic?: boolean;
}

export type AddRecipeToMealRequestMealType =
  (typeof AddRecipeToMealRequestMealType)[keyof typeof AddRecipeToMealRequestMealType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AddRecipeToMealRequestMealType = {
  breakfast: "breakfast",
  lunch: "lunch",
  dinner: "dinner",
  snack: "snack",
  other: "other",
} as const;

export interface AddRecipeToMealRequest {
  date: string;
  mealType: AddRecipeToMealRequestMealType;
  /** –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ä—Ü–∏–π (–º–æ–∂–Ω–æ –¥—Ä–æ–±–Ω–æ–µ) */
  servings: number;
  /** @pattern ^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$ */
  time?: string;
}

export interface AiParseMealRequest {
  text: string;
}

export type AiParseMealResponseParsedType =
  (typeof AiParseMealResponseParsedType)[keyof typeof AiParseMealResponseParsedType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AiParseMealResponseParsedType = {
  breakfast: "breakfast",
  lunch: "lunch",
  dinner: "dinner",
  snack: "snack",
  other: "other",
} as const;

export type AiParseMealResponseParsedItemsItemProductSuggestionsItem = {
  productId?: string;
  name?: string;
  kcalPer100g?: number;
  source?: string;
  matchScore?: number;
};

export type AiParseMealResponseParsedItemsItemRecipeSuggestionsItem = {
  recipeId?: string;
  name?: string;
  kcalPerServing?: number;
  servings?: number;
  usageCount?: number;
  matchScore?: number;
};

/**
 * @nullable
 */
export type AiParseMealResponseParsedItemsItemAiFallback = {
  name?: string;
  kcalPer100g?: number;
  proteinPer100g?: number;
  fatPer100g?: number;
  carbsPer100g?: number;
  confidence?: number;
} | null;

export type AiParseMealResponseParsedItemsItem = {
  rawText?: string;
  parsedName?: string;
  quantity?: number;
  unit?: string;
  productSuggestions?: AiParseMealResponseParsedItemsItemProductSuggestionsItem[];
  recipeSuggestions?: AiParseMealResponseParsedItemsItemRecipeSuggestionsItem[];
  /** @nullable */
  aiFallback?: AiParseMealResponseParsedItemsItemAiFallback;
};

export type AiParseMealResponseParsed = {
  type?: AiParseMealResponseParsedType;
  items?: AiParseMealResponseParsedItemsItem[];
};

export interface AiParseMealResponse {
  parsed?: AiParseMealResponseParsed;
  /** –°–ø–∏—Å–æ–∫ items —Å –Ω–∏–∑–∫–∏–º confidence */
  needsReview?: string[];
}

export type StatsResponsePeriod = {
  from?: string;
  to?: string;
};

export type StatsResponseAverageMacros = {
  protein?: number;
  fat?: number;
  carbs?: number;
};

export interface StatsResponse {
  period?: StatsResponsePeriod;
  averageKcal?: number;
  totalKcal?: number;
  daysTracked?: number;
  averageMacros?: StatsResponseAverageMacros;
}

export type ErrorDetails = { [key: string]: unknown };

export interface Error {
  error?: string;
  message?: string;
  details?: ErrorDetails;
}

/**
 * –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
 */
export type BadRequestResponse = Error;

/**
 * –¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
 */
export type UnauthorizedResponse = Error;

/**
 * –†–µ—Å—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω
 */
export type NotFoundResponse = Error;

export type GetCalendarParams = {
  /**
   * @pattern ^\d{4}-\d{2}$
   */
  month: string;
};

export type GetCalendar200 = {
  month?: string;
  days?: CalendarDay[];
};

export type GetProductsParams = {
  /**
   * –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
   */
  search?: string;
  category?: string;
  source?: GetProductsSource;
  limit?: number;
  offset?: number;
};

export type GetProductsSource =
  (typeof GetProductsSource)[keyof typeof GetProductsSource];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetProductsSource = {
  manual: "manual",
  ai: "ai",
  openfoodfacts: "openfoodfacts",
  user: "user",
} as const;

export type GetProducts200 = {
  products?: Product[];
  total?: number;
};

export type GetProductsSearchParams = {
  q: string;
  limit?: number;
};

export type GetProductsSearch200 = {
  products?: Product[];
};

export type GetRecipesParams = {
  category?: GetRecipesCategory;
  /**
   * –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
   */
  search?: string;
  sort?: GetRecipesSort;
  limit?: number;
  offset?: number;
};

export type GetRecipesCategory =
  (typeof GetRecipesCategory)[keyof typeof GetRecipesCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetRecipesCategory = {
  breakfast: "breakfast",
  lunch: "lunch",
  dinner: "dinner",
  snack: "snack",
  dessert: "dessert",
  drink: "drink",
  other: "other",
} as const;

export type GetRecipesSort =
  (typeof GetRecipesSort)[keyof typeof GetRecipesSort];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetRecipesSort = {
  recent: "recent",
  popular: "popular",
  name: "name",
} as const;

export type GetRecipes200 = {
  recipes?: Recipe[];
  total?: number;
};

export type GetRecipesPublicParams = {
  search?: string;
  category?: string;
  /**
   * –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞–ª–æ—Ä–∏—è–º –Ω–∞ –ø–æ—Ä—Ü–∏—é
   */
  maxKcal?: number;
  limit?: number;
};

export type GetRecipesPublic200 = {
  recipes?: Recipe[];
};

export type GetPlans200 = {
  plans?: DietPlan[];
};

export type PostPlansIdApplyParams = {
  date?: string;
};

export type PostPlansIdApply200 = {
  message?: string;
  appliedTo?: string;
};

export type GetStatsParams = {
  from: string;
  to: string;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const postAuthSignup = (
  signupRequest: BodyType<SignupRequest>,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<AuthResponse>(
    {
      url: `/auth/signup`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: signupRequest,
      signal,
    },
    options,
  );
};

export const getPostAuthSignupMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthSignup>>,
    TError,
    { data: BodyType<SignupRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthSignup>>,
  TError,
  { data: BodyType<SignupRequest> },
  TContext
> => {
  const mutationKey = ["postAuthSignup"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthSignup>>,
    { data: BodyType<SignupRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthSignup(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthSignup>>
>;
export type PostAuthSignupMutationBody = BodyType<SignupRequest>;
export type PostAuthSignupMutationError = ErrorType<Error>;

/**
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const usePostAuthSignup = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthSignup>>,
      TError,
      { data: BodyType<SignupRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthSignup>>,
  TError,
  { data: BodyType<SignupRequest> },
  TContext
> => {
  const mutationOptions = getPostAuthSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –í—Ö–æ–¥ —Å email –∏ –ø–∞—Ä–æ–ª–µ–º
 */
export const postAuthLogin = (
  loginRequest: BodyType<LoginRequest>,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<AuthResponse>(
    {
      url: `/auth/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginRequest,
      signal,
    },
    options,
  );
};

export const getPostAuthLoginMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthLogin>>,
    TError,
    { data: BodyType<LoginRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthLogin>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationKey = ["postAuthLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthLogin>>,
    { data: BodyType<LoginRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthLogin>>
>;
export type PostAuthLoginMutationBody = BodyType<LoginRequest>;
export type PostAuthLoginMutationError = ErrorType<Error>;

/**
 * @summary –í—Ö–æ–¥ —Å email –∏ –ø–∞—Ä–æ–ª–µ–º
 */
export const usePostAuthLogin = <TError = ErrorType<Error>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthLogin>>,
      TError,
      { data: BodyType<LoginRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthLogin>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationOptions = getPostAuthLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —á–µ—Ä–µ–∑ Google OAuth ID token
 * @summary –í—Ö–æ–¥ —á–µ—Ä–µ–∑ Google (Gmail)
 */
export const postAuthGoogle = (
  googleAuthRequest: BodyType<GoogleAuthRequest>,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<AuthResponse>(
    {
      url: `/auth/google`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: googleAuthRequest,
      signal,
    },
    options,
  );
};

export const getPostAuthGoogleMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthGoogle>>,
    TError,
    { data: BodyType<GoogleAuthRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthGoogle>>,
  TError,
  { data: BodyType<GoogleAuthRequest> },
  TContext
> => {
  const mutationKey = ["postAuthGoogle"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthGoogle>>,
    { data: BodyType<GoogleAuthRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthGoogle(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthGoogleMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthGoogle>>
>;
export type PostAuthGoogleMutationBody = BodyType<GoogleAuthRequest>;
export type PostAuthGoogleMutationError = ErrorType<Error>;

/**
 * @summary –í—Ö–æ–¥ —á–µ—Ä–µ–∑ Google (Gmail)
 */
export const usePostAuthGoogle = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthGoogle>>,
      TError,
      { data: BodyType<GoogleAuthRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthGoogle>>,
  TError,
  { data: BodyType<GoogleAuthRequest> },
  TContext
> => {
  const mutationOptions = getPostAuthGoogleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞–ª–µ–Ω–¥–∞—Ä—å –∑–∞ –º–µ—Å—è—Ü
 */
export const getCalendar = (
  params: GetCalendarParams,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<GetCalendar200>(
    { url: `/calendar`, method: "GET", params, signal },
    options,
  );
};

export const getGetCalendarQueryKey = (params?: GetCalendarParams) => {
  return [`/calendar`, ...(params ? [params] : [])] as const;
};

export const getGetCalendarQueryOptions = <
  TData = Awaited<ReturnType<typeof getCalendar>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetCalendarParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCalendar>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCalendarQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCalendar>>> = ({
    signal,
  }) => getCalendar(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCalendar>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCalendarQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCalendar>>
>;
export type GetCalendarQueryError = ErrorType<UnauthorizedResponse>;

export function useGetCalendar<
  TData = Awaited<ReturnType<typeof getCalendar>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetCalendarParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCalendar>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCalendar>>,
          TError,
          Awaited<ReturnType<typeof getCalendar>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCalendar<
  TData = Awaited<ReturnType<typeof getCalendar>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetCalendarParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCalendar>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCalendar>>,
          TError,
          Awaited<ReturnType<typeof getCalendar>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCalendar<
  TData = Awaited<ReturnType<typeof getCalendar>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetCalendarParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCalendar>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞–ª–µ–Ω–¥–∞—Ä—å –∑–∞ –º–µ—Å—è—Ü
 */

export function useGetCalendar<
  TData = Awaited<ReturnType<typeof getCalendar>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetCalendarParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCalendar>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCalendarQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∑–∞ –¥–µ–Ω—å
 */
export const getDayDate = (
  date: string,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<DayEntry>(
    { url: `/day/${date}`, method: "GET", signal },
    options,
  );
};

export const getGetDayDateQueryKey = (date?: string) => {
  return [`/day/${date}`] as const;
};

export const getGetDayDateQueryOptions = <
  TData = Awaited<ReturnType<typeof getDayDate>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDayDate>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDayDateQueryKey(date);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDayDate>>> = ({
    signal,
  }) => getDayDate(date, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!date,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDayDate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDayDateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDayDate>>
>;
export type GetDayDateQueryError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

export function useGetDayDate<
  TData = Awaited<ReturnType<typeof getDayDate>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  date: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDayDate>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDayDate>>,
          TError,
          Awaited<ReturnType<typeof getDayDate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDayDate<
  TData = Awaited<ReturnType<typeof getDayDate>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDayDate>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDayDate>>,
          TError,
          Awaited<ReturnType<typeof getDayDate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDayDate<
  TData = Awaited<ReturnType<typeof getDayDate>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDayDate>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∑–∞ –¥–µ–Ω—å
 */

export function useGetDayDate<
  TData = Awaited<ReturnType<typeof getDayDate>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDayDate>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDayDateQueryOptions(date, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –°–æ–∑–¥–∞—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const postDayDateMeals = (
  date: string,
  createMealRequest: BodyType<CreateMealRequest>,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<Meal>(
    {
      url: `/day/${date}/meals`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createMealRequest,
      signal,
    },
    options,
  );
};

export const getPostDayDateMealsMutationOptions = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postDayDateMeals>>,
    TError,
    { date: string; data: BodyType<CreateMealRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postDayDateMeals>>,
  TError,
  { date: string; data: BodyType<CreateMealRequest> },
  TContext
> => {
  const mutationKey = ["postDayDateMeals"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postDayDateMeals>>,
    { date: string; data: BodyType<CreateMealRequest> }
  > = (props) => {
    const { date, data } = props ?? {};

    return postDayDateMeals(date, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostDayDateMealsMutationResult = NonNullable<
  Awaited<ReturnType<typeof postDayDateMeals>>
>;
export type PostDayDateMealsMutationBody = BodyType<CreateMealRequest>;
export type PostDayDateMealsMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse
>;

/**
 * @summary –°–æ–∑–¥–∞—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const usePostDayDateMeals = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postDayDateMeals>>,
      TError,
      { date: string; data: BodyType<CreateMealRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postDayDateMeals>>,
  TError,
  { date: string; data: BodyType<CreateMealRequest> },
  TContext
> => {
  const mutationOptions = getPostDayDateMealsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const putMealsId = (
  id: string,
  createMealRequest: BodyType<CreateMealRequest>,
  options?: SecondParameter<typeof createInstance>,
) => {
  return createInstance<Meal>(
    {
      url: `/meals/${id}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: createMealRequest,
    },
    options,
  );
};

export const getPutMealsIdMutationOptions = <
  TError = ErrorType<
    BadRequestResponse | UnauthorizedResponse | NotFoundResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putMealsId>>,
    TError,
    { id: string; data: BodyType<CreateMealRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putMealsId>>,
  TError,
  { id: string; data: BodyType<CreateMealRequest> },
  TContext
> => {
  const mutationKey = ["putMealsId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putMealsId>>,
    { id: string; data: BodyType<CreateMealRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return putMealsId(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutMealsIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof putMealsId>>
>;
export type PutMealsIdMutationBody = BodyType<CreateMealRequest>;
export type PutMealsIdMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const usePutMealsId = <
  TError = ErrorType<
    BadRequestResponse | UnauthorizedResponse | NotFoundResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putMealsId>>,
      TError,
      { id: string; data: BodyType<CreateMealRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putMealsId>>,
  TError,
  { id: string; data: BodyType<CreateMealRequest> },
  TContext
> => {
  const mutationOptions = getPutMealsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const deleteMealsId = (
  id: string,
  options?: SecondParameter<typeof createInstance>,
) => {
  return createInstance<void>(
    { url: `/meals/${id}`, method: "DELETE" },
    options,
  );
};

export const getDeleteMealsIdMutationOptions = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMealsId>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMealsId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteMealsId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMealsId>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteMealsId(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteMealsIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMealsId>>
>;

export type DeleteMealsIdMutationError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const useDeleteMealsId = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMealsId>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMealsId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteMealsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –†–∞—Å–ø–∞—Ä—Å–∏—Ç—å —Ç–µ–∫—Å—Ç —á–µ—Ä–µ–∑ AI
 */
export const postAiParseMeal = (
  aiParseMealRequest: BodyType<AiParseMealRequest>,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<AiParseMealResponse>(
    {
      url: `/ai/parse-meal`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: aiParseMealRequest,
      signal,
    },
    options,
  );
};

export const getPostAiParseMealMutationOptions = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse | Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAiParseMeal>>,
    TError,
    { data: BodyType<AiParseMealRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAiParseMeal>>,
  TError,
  { data: BodyType<AiParseMealRequest> },
  TContext
> => {
  const mutationKey = ["postAiParseMeal"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAiParseMeal>>,
    { data: BodyType<AiParseMealRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return postAiParseMeal(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAiParseMealMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAiParseMeal>>
>;
export type PostAiParseMealMutationBody = BodyType<AiParseMealRequest>;
export type PostAiParseMealMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse | Error
>;

/**
 * @summary –†–∞—Å–ø–∞—Ä—Å–∏—Ç—å —Ç–µ–∫—Å—Ç —á–µ—Ä–µ–∑ AI
 */
export const usePostAiParseMeal = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse | Error>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAiParseMeal>>,
      TError,
      { data: BodyType<AiParseMealRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAiParseMeal>>,
  TError,
  { data: BodyType<AiParseMealRequest> },
  TContext
> => {
  const mutationOptions = getPostAiParseMealMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
 */
export const getProducts = (
  params?: GetProductsParams,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<GetProducts200>(
    { url: `/products`, method: "GET", params, signal },
    options,
  );
};

export const getGetProductsQueryKey = (params?: GetProductsParams) => {
  return [`/products`, ...(params ? [params] : [])] as const;
};

export const getGetProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof getProducts>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params?: GetProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProducts>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProducts>>> = ({
    signal,
  }) => getProducts(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProducts>>
>;
export type GetProductsQueryError = ErrorType<UnauthorizedResponse>;

export function useGetProducts<
  TData = Awaited<ReturnType<typeof getProducts>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: undefined | GetProductsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProducts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProducts>>,
          TError,
          Awaited<ReturnType<typeof getProducts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProducts<
  TData = Awaited<ReturnType<typeof getProducts>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params?: GetProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProducts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProducts>>,
          TError,
          Awaited<ReturnType<typeof getProducts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProducts<
  TData = Awaited<ReturnType<typeof getProducts>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params?: GetProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProducts>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
 */

export function useGetProducts<
  TData = Awaited<ReturnType<typeof getProducts>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params?: GetProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProducts>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProductsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–¥—É–∫—Ç
 */
export const postProducts = (
  createProductRequest: BodyType<CreateProductRequest>,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<Product>(
    {
      url: `/products`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createProductRequest,
      signal,
    },
    options,
  );
};

export const getPostProductsMutationOptions = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postProducts>>,
    TError,
    { data: BodyType<CreateProductRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postProducts>>,
  TError,
  { data: BodyType<CreateProductRequest> },
  TContext
> => {
  const mutationKey = ["postProducts"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postProducts>>,
    { data: BodyType<CreateProductRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return postProducts(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostProductsMutationResult = NonNullable<
  Awaited<ReturnType<typeof postProducts>>
>;
export type PostProductsMutationBody = BodyType<CreateProductRequest>;
export type PostProductsMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse
>;

/**
 * @summary –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–¥—É–∫—Ç
 */
export const usePostProducts = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postProducts>>,
      TError,
      { data: BodyType<CreateProductRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postProducts>>,
  TError,
  { data: BodyType<CreateProductRequest> },
  TContext
> => {
  const mutationOptions = getPostProductsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ (–¥–ª—è –∞–≤—Ç–æ–∫–æ–º–ø–ª–∏—Ç–∞)
 */
export const getProductsSearch = (
  params: GetProductsSearchParams,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<GetProductsSearch200>(
    { url: `/products/search`, method: "GET", params, signal },
    options,
  );
};

export const getGetProductsSearchQueryKey = (
  params?: GetProductsSearchParams,
) => {
  return [`/products/search`, ...(params ? [params] : [])] as const;
};

export const getGetProductsSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsSearch>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetProductsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof createInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsSearchQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsSearch>>
  > = ({ signal }) => getProductsSearch(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductsSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsSearch>>
>;
export type GetProductsSearchQueryError = ErrorType<UnauthorizedResponse>;

export function useGetProductsSearch<
  TData = Awaited<ReturnType<typeof getProductsSearch>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetProductsSearchParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsSearch>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsSearch>>,
          TError,
          Awaited<ReturnType<typeof getProductsSearch>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProductsSearch<
  TData = Awaited<ReturnType<typeof getProductsSearch>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetProductsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsSearch>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsSearch>>,
          TError,
          Awaited<ReturnType<typeof getProductsSearch>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProductsSearch<
  TData = Awaited<ReturnType<typeof getProductsSearch>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetProductsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ (–¥–ª—è –∞–≤—Ç–æ–∫–æ–º–ø–ª–∏—Ç–∞)
 */

export function useGetProductsSearch<
  TData = Awaited<ReturnType<typeof getProductsSearch>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetProductsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProductsSearchQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ ID
 */
export const getProductsId = (
  id: string,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<Product>(
    { url: `/products/${id}`, method: "GET", signal },
    options,
  );
};

export const getGetProductsIdQueryKey = (id?: string) => {
  return [`/products/${id}`] as const;
};

export const getGetProductsIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsId>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProductsId>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductsIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductsId>>> = ({
    signal,
  }) => getProductsId(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductsIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsId>>
>;
export type GetProductsIdQueryError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

export function useGetProductsId<
  TData = Awaited<ReturnType<typeof getProductsId>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProductsId>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsId>>,
          TError,
          Awaited<ReturnType<typeof getProductsId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProductsId<
  TData = Awaited<ReturnType<typeof getProductsId>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProductsId>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsId>>,
          TError,
          Awaited<ReturnType<typeof getProductsId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProductsId<
  TData = Awaited<ReturnType<typeof getProductsId>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProductsId>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ ID
 */

export function useGetProductsId<
  TData = Awaited<ReturnType<typeof getProductsId>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProductsId>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProductsIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const putProductsId = (
  id: string,
  updateProductRequest: BodyType<UpdateProductRequest>,
  options?: SecondParameter<typeof createInstance>,
) => {
  return createInstance<Product>(
    {
      url: `/products/${id}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: updateProductRequest,
    },
    options,
  );
};

export const getPutProductsIdMutationOptions = <
  TError = ErrorType<
    BadRequestResponse | UnauthorizedResponse | NotFoundResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putProductsId>>,
    TError,
    { id: string; data: BodyType<UpdateProductRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putProductsId>>,
  TError,
  { id: string; data: BodyType<UpdateProductRequest> },
  TContext
> => {
  const mutationKey = ["putProductsId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putProductsId>>,
    { id: string; data: BodyType<UpdateProductRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return putProductsId(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutProductsIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof putProductsId>>
>;
export type PutProductsIdMutationBody = BodyType<UpdateProductRequest>;
export type PutProductsIdMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const usePutProductsId = <
  TError = ErrorType<
    BadRequestResponse | UnauthorizedResponse | NotFoundResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putProductsId>>,
      TError,
      { id: string; data: BodyType<UpdateProductRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putProductsId>>,
  TError,
  { id: string; data: BodyType<UpdateProductRequest> },
  TContext
> => {
  const mutationOptions = getPutProductsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const deleteProductsId = (
  id: string,
  options?: SecondParameter<typeof createInstance>,
) => {
  return createInstance<void>(
    { url: `/products/${id}`, method: "DELETE" },
    options,
  );
};

export const getDeleteProductsIdMutationOptions = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProductsId>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProductsId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteProductsId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProductsId>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteProductsId(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProductsIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProductsId>>
>;

export type DeleteProductsIdMutationError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const useDeleteProductsId = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProductsId>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProductsId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteProductsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–∞ –ø–æ —à—Ç—Ä–∏—Ö–∫–æ–¥—É
 */
export const getProductsBarcodeBarcode = (
  barcode: string,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<Product>(
    { url: `/products/barcode/${barcode}`, method: "GET", signal },
    options,
  );
};

export const getGetProductsBarcodeBarcodeQueryKey = (barcode?: string) => {
  return [`/products/barcode/${barcode}`] as const;
};

export const getGetProductsBarcodeBarcodeQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
  TError = ErrorType<Error>,
>(
  barcode: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof createInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsBarcodeBarcodeQueryKey(barcode);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsBarcodeBarcode>>
  > = ({ signal }) =>
    getProductsBarcodeBarcode(barcode, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!barcode,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductsBarcodeBarcodeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsBarcodeBarcode>>
>;
export type GetProductsBarcodeBarcodeQueryError = ErrorType<Error>;

export function useGetProductsBarcodeBarcode<
  TData = Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
  TError = ErrorType<Error>,
>(
  barcode: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
          TError,
          Awaited<ReturnType<typeof getProductsBarcodeBarcode>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProductsBarcodeBarcode<
  TData = Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
  TError = ErrorType<Error>,
>(
  barcode: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
          TError,
          Awaited<ReturnType<typeof getProductsBarcodeBarcode>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProductsBarcodeBarcode<
  TData = Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
  TError = ErrorType<Error>,
>(
  barcode: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–∞ –ø–æ —à—Ç—Ä–∏—Ö–∫–æ–¥—É
 */

export function useGetProductsBarcodeBarcode<
  TData = Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
  TError = ErrorType<Error>,
>(
  barcode: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsBarcodeBarcode>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProductsBarcodeBarcodeQueryOptions(
    barcode,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ä–µ—Ü–µ–ø—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const getRecipes = (
  params?: GetRecipesParams,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<GetRecipes200>(
    { url: `/recipes`, method: "GET", params, signal },
    options,
  );
};

export const getGetRecipesQueryKey = (params?: GetRecipesParams) => {
  return [`/recipes`, ...(params ? [params] : [])] as const;
};

export const getGetRecipesQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecipes>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params?: GetRecipesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecipes>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecipesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecipes>>> = ({
    signal,
  }) => getRecipes(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecipes>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecipesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecipes>>
>;
export type GetRecipesQueryError = ErrorType<UnauthorizedResponse>;

export function useGetRecipes<
  TData = Awaited<ReturnType<typeof getRecipes>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: undefined | GetRecipesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecipes>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecipes>>,
          TError,
          Awaited<ReturnType<typeof getRecipes>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecipes<
  TData = Awaited<ReturnType<typeof getRecipes>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params?: GetRecipesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecipes>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecipes>>,
          TError,
          Awaited<ReturnType<typeof getRecipes>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecipes<
  TData = Awaited<ReturnType<typeof getRecipes>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params?: GetRecipesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecipes>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ä–µ—Ü–µ–ø—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */

export function useGetRecipes<
  TData = Awaited<ReturnType<typeof getRecipes>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params?: GetRecipesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecipes>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRecipesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Ä–µ—Ü–µ–ø—Ç
 */
export const postRecipes = (
  createRecipeRequest: BodyType<CreateRecipeRequest>,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<Recipe>(
    {
      url: `/recipes`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createRecipeRequest,
      signal,
    },
    options,
  );
};

export const getPostRecipesMutationOptions = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postRecipes>>,
    TError,
    { data: BodyType<CreateRecipeRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postRecipes>>,
  TError,
  { data: BodyType<CreateRecipeRequest> },
  TContext
> => {
  const mutationKey = ["postRecipes"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postRecipes>>,
    { data: BodyType<CreateRecipeRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return postRecipes(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostRecipesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postRecipes>>
>;
export type PostRecipesMutationBody = BodyType<CreateRecipeRequest>;
export type PostRecipesMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse
>;

/**
 * @summary –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Ä–µ—Ü–µ–ø—Ç
 */
export const usePostRecipes = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postRecipes>>,
      TError,
      { data: BodyType<CreateRecipeRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postRecipes>>,
  TError,
  { data: BodyType<CreateRecipeRequest> },
  TContext
> => {
  const mutationOptions = getPostRecipesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç
 */
export const getRecipesId = (
  id: string,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<Recipe>(
    { url: `/recipes/${id}`, method: "GET", signal },
    options,
  );
};

export const getGetRecipesIdQueryKey = (id?: string) => {
  return [`/recipes/${id}`] as const;
};

export const getGetRecipesIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecipesId>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecipesId>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecipesIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecipesId>>> = ({
    signal,
  }) => getRecipesId(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecipesId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecipesIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecipesId>>
>;
export type GetRecipesIdQueryError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

export function useGetRecipesId<
  TData = Awaited<ReturnType<typeof getRecipesId>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecipesId>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecipesId>>,
          TError,
          Awaited<ReturnType<typeof getRecipesId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecipesId<
  TData = Awaited<ReturnType<typeof getRecipesId>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecipesId>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecipesId>>,
          TError,
          Awaited<ReturnType<typeof getRecipesId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecipesId<
  TData = Awaited<ReturnType<typeof getRecipesId>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecipesId>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç
 */

export function useGetRecipesId<
  TData = Awaited<ReturnType<typeof getRecipesId>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecipesId>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRecipesIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –û–±–Ω–æ–≤–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç
 */
export const putRecipesId = (
  id: string,
  updateRecipeRequest: BodyType<UpdateRecipeRequest>,
  options?: SecondParameter<typeof createInstance>,
) => {
  return createInstance<Recipe>(
    {
      url: `/recipes/${id}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: updateRecipeRequest,
    },
    options,
  );
};

export const getPutRecipesIdMutationOptions = <
  TError = ErrorType<
    BadRequestResponse | UnauthorizedResponse | NotFoundResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putRecipesId>>,
    TError,
    { id: string; data: BodyType<UpdateRecipeRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putRecipesId>>,
  TError,
  { id: string; data: BodyType<UpdateRecipeRequest> },
  TContext
> => {
  const mutationKey = ["putRecipesId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putRecipesId>>,
    { id: string; data: BodyType<UpdateRecipeRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return putRecipesId(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutRecipesIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof putRecipesId>>
>;
export type PutRecipesIdMutationBody = BodyType<UpdateRecipeRequest>;
export type PutRecipesIdMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –û–±–Ω–æ–≤–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç
 */
export const usePutRecipesId = <
  TError = ErrorType<
    BadRequestResponse | UnauthorizedResponse | NotFoundResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putRecipesId>>,
      TError,
      { id: string; data: BodyType<UpdateRecipeRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putRecipesId>>,
  TError,
  { id: string; data: BodyType<UpdateRecipeRequest> },
  TContext
> => {
  const mutationOptions = getPutRecipesIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –£–¥–∞–ª–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç
 */
export const deleteRecipesId = (
  id: string,
  options?: SecondParameter<typeof createInstance>,
) => {
  return createInstance<void>(
    { url: `/recipes/${id}`, method: "DELETE" },
    options,
  );
};

export const getDeleteRecipesIdMutationOptions = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRecipesId>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRecipesId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteRecipesId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRecipesId>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteRecipesId(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteRecipesIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRecipesId>>
>;

export type DeleteRecipesIdMutationError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –£–¥–∞–ª–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç
 */
export const useDeleteRecipesId = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteRecipesId>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteRecipesId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteRecipesIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å —Ä–µ—Ü–µ–ø—Ç (–¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —á—É–∂–æ–≥–æ)
 */
export const postRecipesIdDuplicate = (
  id: string,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<Recipe>(
    { url: `/recipes/${id}/duplicate`, method: "POST", signal },
    options,
  );
};

export const getPostRecipesIdDuplicateMutationOptions = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postRecipesIdDuplicate>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postRecipesIdDuplicate>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["postRecipesIdDuplicate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postRecipesIdDuplicate>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return postRecipesIdDuplicate(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostRecipesIdDuplicateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postRecipesIdDuplicate>>
>;

export type PostRecipesIdDuplicateMutationError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å —Ä–µ—Ü–µ–ø—Ç (–¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —á—É–∂–æ–≥–æ)
 */
export const usePostRecipesIdDuplicate = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postRecipesIdDuplicate>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postRecipesIdDuplicate>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getPostRecipesIdDuplicateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * –°–æ–∑–¥–∞—ë—Ç meal –∏–∑ —Ä–µ—Ü–µ–ø—Ç–∞ —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ø–æ—Ä—Ü–∏–π
 * @summary –î–æ–±–∞–≤–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç –≤ –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const postRecipesIdAddToMeal = (
  id: string,
  addRecipeToMealRequest: BodyType<AddRecipeToMealRequest>,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<Meal>(
    {
      url: `/recipes/${id}/add-to-meal`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: addRecipeToMealRequest,
      signal,
    },
    options,
  );
};

export const getPostRecipesIdAddToMealMutationOptions = <
  TError = ErrorType<
    BadRequestResponse | UnauthorizedResponse | NotFoundResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postRecipesIdAddToMeal>>,
    TError,
    { id: string; data: BodyType<AddRecipeToMealRequest> },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postRecipesIdAddToMeal>>,
  TError,
  { id: string; data: BodyType<AddRecipeToMealRequest> },
  TContext
> => {
  const mutationKey = ["postRecipesIdAddToMeal"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postRecipesIdAddToMeal>>,
    { id: string; data: BodyType<AddRecipeToMealRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return postRecipesIdAddToMeal(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostRecipesIdAddToMealMutationResult = NonNullable<
  Awaited<ReturnType<typeof postRecipesIdAddToMeal>>
>;
export type PostRecipesIdAddToMealMutationBody =
  BodyType<AddRecipeToMealRequest>;
export type PostRecipesIdAddToMealMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –î–æ–±–∞–≤–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç –≤ –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const usePostRecipesIdAddToMeal = <
  TError = ErrorType<
    BadRequestResponse | UnauthorizedResponse | NotFoundResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postRecipesIdAddToMeal>>,
      TError,
      { id: string; data: BodyType<AddRecipeToMealRequest> },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postRecipesIdAddToMeal>>,
  TError,
  { id: string; data: BodyType<AddRecipeToMealRequest> },
  TContext
> => {
  const mutationOptions = getPostRecipesIdAddToMealMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –ü–æ–∏—Å–∫ –ø—É–±–ª–∏—á–Ω—ã—Ö —Ä–µ—Ü–µ–ø—Ç–æ–≤
 */
export const getRecipesPublic = (
  params?: GetRecipesPublicParams,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<GetRecipesPublic200>(
    { url: `/recipes/public`, method: "GET", params, signal },
    options,
  );
};

export const getGetRecipesPublicQueryKey = (
  params?: GetRecipesPublicParams,
) => {
  return [`/recipes/public`, ...(params ? [params] : [])] as const;
};

export const getGetRecipesPublicQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecipesPublic>>,
  TError = ErrorType<unknown>,
>(
  params?: GetRecipesPublicParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecipesPublic>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof createInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecipesPublicQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecipesPublic>>
  > = ({ signal }) => getRecipesPublic(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecipesPublic>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecipesPublicQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecipesPublic>>
>;
export type GetRecipesPublicQueryError = ErrorType<unknown>;

export function useGetRecipesPublic<
  TData = Awaited<ReturnType<typeof getRecipesPublic>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | GetRecipesPublicParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecipesPublic>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecipesPublic>>,
          TError,
          Awaited<ReturnType<typeof getRecipesPublic>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecipesPublic<
  TData = Awaited<ReturnType<typeof getRecipesPublic>>,
  TError = ErrorType<unknown>,
>(
  params?: GetRecipesPublicParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecipesPublic>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecipesPublic>>,
          TError,
          Awaited<ReturnType<typeof getRecipesPublic>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecipesPublic<
  TData = Awaited<ReturnType<typeof getRecipesPublic>>,
  TError = ErrorType<unknown>,
>(
  params?: GetRecipesPublicParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecipesPublic>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–∏—Å–∫ –ø—É–±–ª–∏—á–Ω—ã—Ö —Ä–µ—Ü–µ–ø—Ç–æ–≤
 */

export function useGetRecipesPublic<
  TData = Awaited<ReturnType<typeof getRecipesPublic>>,
  TError = ErrorType<unknown>,
>(
  params?: GetRecipesPublicParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecipesPublic>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRecipesPublicQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–ª–∞–Ω–æ–≤
 */
export const getPlans = (
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<GetPlans200>(
    { url: `/plans`, method: "GET", signal },
    options,
  );
};

export const getGetPlansQueryKey = () => {
  return [`/plans`] as const;
};

export const getGetPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = ErrorType<UnauthorizedResponse>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
  >;
  request?: SecondParameter<typeof createInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPlansQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlans>>> = ({
    signal,
  }) => getPlans(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPlans>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlans>>
>;
export type GetPlansQueryError = ErrorType<UnauthorizedResponse>;

export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlans>>,
          TError,
          Awaited<ReturnType<typeof getPlans>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlans>>,
          TError,
          Awaited<ReturnType<typeof getPlans>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–ª–∞–Ω–æ–≤
 */

export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPlansQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –ü—Ä–∏–º–µ–Ω–∏—Ç—å –ø–ª–∞–Ω
 */
export const postPlansIdApply = (
  id: string,
  params?: PostPlansIdApplyParams,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<PostPlansIdApply200>(
    { url: `/plans/${id}/apply`, method: "POST", params, signal },
    options,
  );
};

export const getPostPlansIdApplyMutationOptions = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postPlansIdApply>>,
    TError,
    { id: string; params?: PostPlansIdApplyParams },
    TContext
  >;
  request?: SecondParameter<typeof createInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postPlansIdApply>>,
  TError,
  { id: string; params?: PostPlansIdApplyParams },
  TContext
> => {
  const mutationKey = ["postPlansIdApply"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPlansIdApply>>,
    { id: string; params?: PostPlansIdApplyParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return postPlansIdApply(id, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPlansIdApplyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPlansIdApply>>
>;

export type PostPlansIdApplyMutationError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –ü—Ä–∏–º–µ–Ω–∏—Ç—å –ø–ª–∞–Ω
 */
export const usePostPlansIdApply = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postPlansIdApply>>,
      TError,
      { id: string; params?: PostPlansIdApplyParams },
      TContext
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postPlansIdApply>>,
  TError,
  { id: string; params?: PostPlansIdApplyParams },
  TContext
> => {
  const mutationOptions = getPostPlansIdApplyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–µ—Ä–∏–æ–¥
 */
export const getStats = (
  params: GetStatsParams,
  options?: SecondParameter<typeof createInstance>,
  signal?: AbortSignal,
) => {
  return createInstance<StatsResponse>(
    { url: `/stats`, method: "GET", params, signal },
    options,
  );
};

export const getGetStatsQueryKey = (params?: GetStatsParams) => {
  return [`/stats`, ...(params ? [params] : [])] as const;
};

export const getGetStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof getStats>>,
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
>(
  params: GetStatsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStatsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStats>>> = ({
    signal,
  }) => getStats(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStats>>
>;
export type GetStatsQueryError = ErrorType<
  BadRequestResponse | UnauthorizedResponse
>;

export function useGetStats<
  TData = Awaited<ReturnType<typeof getStats>>,
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
>(
  params: GetStatsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStats>>,
          TError,
          Awaited<ReturnType<typeof getStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStats<
  TData = Awaited<ReturnType<typeof getStats>>,
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
>(
  params: GetStatsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStats>>,
          TError,
          Awaited<ReturnType<typeof getStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStats<
  TData = Awaited<ReturnType<typeof getStats>>,
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
>(
  params: GetStatsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–µ—Ä–∏–æ–¥
 */

export function useGetStats<
  TData = Awaited<ReturnType<typeof getStats>>,
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
>(
  params: GetStatsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof createInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetStatsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPostAuthSignupResponseMock = (
  overrideResponse: Partial<AuthResponse> = {},
): AuthResponse => ({
  token: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  user: faker.helpers.arrayElement([
    {
      id: faker.string.uuid(),
      email: faker.internet.email(),
      passwordHash: faker.string.alpha({ length: { min: 10, max: 20 } }),
      displayName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      timezone: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      dailyKcalGoal: faker.helpers.arrayElement([
        faker.number.int({ min: 0, max: undefined }),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    },
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostAuthLoginResponseMock = (
  overrideResponse: Partial<AuthResponse> = {},
): AuthResponse => ({
  token: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  user: faker.helpers.arrayElement([
    {
      id: faker.string.uuid(),
      email: faker.internet.email(),
      passwordHash: faker.string.alpha({ length: { min: 10, max: 20 } }),
      displayName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      timezone: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      dailyKcalGoal: faker.helpers.arrayElement([
        faker.number.int({ min: 0, max: undefined }),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    },
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostAuthGoogleResponseMock = (
  overrideResponse: Partial<AuthResponse> = {},
): AuthResponse => ({
  token: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  user: faker.helpers.arrayElement([
    {
      id: faker.string.uuid(),
      email: faker.internet.email(),
      passwordHash: faker.string.alpha({ length: { min: 10, max: 20 } }),
      displayName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      timezone: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      dailyKcalGoal: faker.helpers.arrayElement([
        faker.number.int({ min: 0, max: undefined }),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    },
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetCalendarResponseMock = (
  overrideResponse: Partial<GetCalendar200> = {},
): GetCalendar200 => ({
  month: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  days: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      date: faker.date.past().toISOString().split("T")[0],
      consumedKcal: faker.number.int({ min: 0, max: undefined }),
      targetKcal: faker.number.int({ min: 0, max: undefined }),
      consumedPercent: faker.number.float({
        min: 0,
        max: 100,
        fractionDigits: 2,
      }),
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetDayDateResponseMock = (
  overrideResponse: Partial<DayEntry> = {},
): DayEntry => ({
  id: faker.string.uuid(),
  userId: faker.string.uuid(),
  date: faker.date.past().toISOString().split("T")[0],
  targetKcal: faker.helpers.arrayElement([
    faker.number.int({ min: 0, max: undefined }),
    undefined,
  ]),
  consumedKcal: faker.helpers.arrayElement([
    faker.number.int({ min: 0, max: undefined }),
    undefined,
  ]),
  notes: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  meals: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      dayEntryId: faker.string.uuid(),
      type: faker.helpers.arrayElement([
        "breakfast",
        "lunch",
        "dinner",
        "snack",
        "other",
      ] as const),
      time: faker.helpers.arrayElement([
        faker.helpers.fromRegExp("^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$"),
        undefined,
      ]),
      name: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      items: faker.helpers.arrayElement([
        Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          id: faker.string.uuid(),
          mealId: faker.string.uuid(),
          productId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([faker.string.uuid(), null]),
            undefined,
          ]),
          recipeId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([faker.string.uuid(), null]),
            undefined,
          ]),
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          quantity: faker.number.float({
            min: undefined,
            max: undefined,
            fractionDigits: 2,
          }),
          unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
          kcal: faker.number.int({ min: 0, max: undefined }),
          protein: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          fat: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          carbs: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          source: faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            undefined,
          ]),
        })),
        undefined,
      ]),
      totalKcal: faker.number.int({ min: 0, max: undefined }),
      source: faker.helpers.arrayElement(["manual", "ai"] as const),
      aiConfidence: faker.helpers.arrayElement([
        faker.number.float({ min: 0, max: 1, fractionDigits: 2 }),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostDayDateMealsResponseMock = (
  overrideResponse: Partial<Meal> = {},
): Meal => ({
  id: faker.string.uuid(),
  dayEntryId: faker.string.uuid(),
  type: faker.helpers.arrayElement([
    "breakfast",
    "lunch",
    "dinner",
    "snack",
    "other",
  ] as const),
  time: faker.helpers.arrayElement([
    faker.helpers.fromRegExp("^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$"),
    undefined,
  ]),
  name: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  items: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      mealId: faker.string.uuid(),
      productId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      recipeId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      quantity: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
      kcal: faker.number.int({ min: 0, max: undefined }),
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      source: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalKcal: faker.number.int({ min: 0, max: undefined }),
  source: faker.helpers.arrayElement(["manual", "ai"] as const),
  aiConfidence: faker.helpers.arrayElement([
    faker.number.float({ min: 0, max: 1, fractionDigits: 2 }),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  ...overrideResponse,
});

export const getPutMealsIdResponseMock = (
  overrideResponse: Partial<Meal> = {},
): Meal => ({
  id: faker.string.uuid(),
  dayEntryId: faker.string.uuid(),
  type: faker.helpers.arrayElement([
    "breakfast",
    "lunch",
    "dinner",
    "snack",
    "other",
  ] as const),
  time: faker.helpers.arrayElement([
    faker.helpers.fromRegExp("^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$"),
    undefined,
  ]),
  name: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  items: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      mealId: faker.string.uuid(),
      productId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      recipeId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      quantity: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
      kcal: faker.number.int({ min: 0, max: undefined }),
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      source: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalKcal: faker.number.int({ min: 0, max: undefined }),
  source: faker.helpers.arrayElement(["manual", "ai"] as const),
  aiConfidence: faker.helpers.arrayElement([
    faker.number.float({ min: 0, max: 1, fractionDigits: 2 }),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  ...overrideResponse,
});

export const getPostAiParseMealResponseMock = (
  overrideResponse: Partial<AiParseMealResponse> = {},
): AiParseMealResponse => ({
  parsed: faker.helpers.arrayElement([
    {
      type: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "breakfast",
          "lunch",
          "dinner",
          "snack",
          "other",
        ] as const),
        undefined,
      ]),
      items: faker.helpers.arrayElement([
        Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          rawText: faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            undefined,
          ]),
          parsedName: faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            undefined,
          ]),
          quantity: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          unit: faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            undefined,
          ]),
          productSuggestions: faker.helpers.arrayElement([
            Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              productId: faker.helpers.arrayElement([
                faker.string.uuid(),
                undefined,
              ]),
              name: faker.helpers.arrayElement([
                faker.string.alpha({ length: { min: 10, max: 20 } }),
                undefined,
              ]),
              kcalPer100g: faker.helpers.arrayElement([
                faker.number.int({ min: undefined, max: undefined }),
                undefined,
              ]),
              source: faker.helpers.arrayElement([
                faker.string.alpha({ length: { min: 10, max: 20 } }),
                undefined,
              ]),
              matchScore: faker.helpers.arrayElement([
                faker.number.float({
                  min: undefined,
                  max: undefined,
                  fractionDigits: 2,
                }),
                undefined,
              ]),
            })),
            undefined,
          ]),
          recipeSuggestions: faker.helpers.arrayElement([
            Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              recipeId: faker.helpers.arrayElement([
                faker.string.uuid(),
                undefined,
              ]),
              name: faker.helpers.arrayElement([
                faker.string.alpha({ length: { min: 10, max: 20 } }),
                undefined,
              ]),
              kcalPerServing: faker.helpers.arrayElement([
                faker.number.int({ min: undefined, max: undefined }),
                undefined,
              ]),
              servings: faker.helpers.arrayElement([
                faker.number.int({ min: undefined, max: undefined }),
                undefined,
              ]),
              usageCount: faker.helpers.arrayElement([
                faker.number.int({ min: undefined, max: undefined }),
                undefined,
              ]),
              matchScore: faker.helpers.arrayElement([
                faker.number.float({
                  min: undefined,
                  max: undefined,
                  fractionDigits: 2,
                }),
                undefined,
              ]),
            })),
            undefined,
          ]),
          aiFallback: faker.helpers.arrayElement([
            {
              name: faker.helpers.arrayElement([
                faker.string.alpha({ length: { min: 10, max: 20 } }),
                undefined,
              ]),
              kcalPer100g: faker.helpers.arrayElement([
                faker.number.int({ min: undefined, max: undefined }),
                undefined,
              ]),
              proteinPer100g: faker.helpers.arrayElement([
                faker.number.float({
                  min: undefined,
                  max: undefined,
                  fractionDigits: 2,
                }),
                undefined,
              ]),
              fatPer100g: faker.helpers.arrayElement([
                faker.number.float({
                  min: undefined,
                  max: undefined,
                  fractionDigits: 2,
                }),
                undefined,
              ]),
              carbsPer100g: faker.helpers.arrayElement([
                faker.number.float({
                  min: undefined,
                  max: undefined,
                  fractionDigits: 2,
                }),
                undefined,
              ]),
              confidence: faker.helpers.arrayElement([
                faker.number.float({
                  min: undefined,
                  max: undefined,
                  fractionDigits: 2,
                }),
                undefined,
              ]),
            },
            undefined,
          ]),
        })),
        undefined,
      ]),
    },
    undefined,
  ]),
  needsReview: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetProductsResponseMock = (
  overrideResponse: Partial<GetProducts200> = {},
): GetProducts200 => ({
  products: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      normalizedName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      kcalPer100g: faker.number.int({ min: undefined, max: undefined }),
      proteinPer100g: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fatPer100g: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbsPer100g: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fiberPer100g: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.number.float({
            min: undefined,
            max: undefined,
            fractionDigits: 2,
          }),
          null,
        ]),
        undefined,
      ]),
      sugarPer100g: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.number.float({
            min: undefined,
            max: undefined,
            fractionDigits: 2,
          }),
          null,
        ]),
        undefined,
      ]),
      source: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "manual",
          "ai",
          "openfoodfacts",
          "user",
        ] as const),
        undefined,
      ]),
      isVerified: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        undefined,
      ]),
      usageCount: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      createdBy: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      barcode: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
      brand: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
      category: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updatedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split(".")[0]}Z`,
        undefined,
      ]),
    })),
    undefined,
  ]),
  total: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostProductsResponseMock = (
  overrideResponse: Partial<Product> = {},
): Product => ({
  id: faker.string.uuid(),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  normalizedName: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  kcalPer100g: faker.number.int({ min: undefined, max: undefined }),
  proteinPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fatPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  carbsPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fiberPer100g: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
      null,
    ]),
    undefined,
  ]),
  sugarPer100g: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
      null,
    ]),
    undefined,
  ]),
  source: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      "manual",
      "ai",
      "openfoodfacts",
      "user",
    ] as const),
    undefined,
  ]),
  isVerified: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  usageCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  createdBy: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  barcode: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  brand: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  category: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetProductsSearchResponseMock = (
  overrideResponse: Partial<GetProductsSearch200> = {},
): GetProductsSearch200 => ({
  products: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      normalizedName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      kcalPer100g: faker.number.int({ min: undefined, max: undefined }),
      proteinPer100g: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fatPer100g: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbsPer100g: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fiberPer100g: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.number.float({
            min: undefined,
            max: undefined,
            fractionDigits: 2,
          }),
          null,
        ]),
        undefined,
      ]),
      sugarPer100g: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.number.float({
            min: undefined,
            max: undefined,
            fractionDigits: 2,
          }),
          null,
        ]),
        undefined,
      ]),
      source: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "manual",
          "ai",
          "openfoodfacts",
          "user",
        ] as const),
        undefined,
      ]),
      isVerified: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        undefined,
      ]),
      usageCount: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      createdBy: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      barcode: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
      brand: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
      category: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updatedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split(".")[0]}Z`,
        undefined,
      ]),
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetProductsIdResponseMock = (
  overrideResponse: Partial<Product> = {},
): Product => ({
  id: faker.string.uuid(),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  normalizedName: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  kcalPer100g: faker.number.int({ min: undefined, max: undefined }),
  proteinPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fatPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  carbsPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fiberPer100g: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
      null,
    ]),
    undefined,
  ]),
  sugarPer100g: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
      null,
    ]),
    undefined,
  ]),
  source: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      "manual",
      "ai",
      "openfoodfacts",
      "user",
    ] as const),
    undefined,
  ]),
  isVerified: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  usageCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  createdBy: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  barcode: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  brand: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  category: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    undefined,
  ]),
  ...overrideResponse,
});

export const getPutProductsIdResponseMock = (
  overrideResponse: Partial<Product> = {},
): Product => ({
  id: faker.string.uuid(),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  normalizedName: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  kcalPer100g: faker.number.int({ min: undefined, max: undefined }),
  proteinPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fatPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  carbsPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fiberPer100g: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
      null,
    ]),
    undefined,
  ]),
  sugarPer100g: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
      null,
    ]),
    undefined,
  ]),
  source: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      "manual",
      "ai",
      "openfoodfacts",
      "user",
    ] as const),
    undefined,
  ]),
  isVerified: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  usageCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  createdBy: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  barcode: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  brand: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  category: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetProductsBarcodeBarcodeResponseMock = (
  overrideResponse: Partial<Product> = {},
): Product => ({
  id: faker.string.uuid(),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  normalizedName: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  kcalPer100g: faker.number.int({ min: undefined, max: undefined }),
  proteinPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fatPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  carbsPer100g: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fiberPer100g: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
      null,
    ]),
    undefined,
  ]),
  sugarPer100g: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
      null,
    ]),
    undefined,
  ]),
  source: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      "manual",
      "ai",
      "openfoodfacts",
      "user",
    ] as const),
    undefined,
  ]),
  isVerified: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  usageCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  createdBy: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  barcode: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  brand: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  category: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split(".")[0]}Z`,
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetRecipesResponseMock = (
  overrideResponse: Partial<GetRecipes200> = {},
): GetRecipes200 => ({
  recipes: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      userId: faker.string.uuid(),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      description: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      servings: faker.number.int({ min: 1, max: undefined }),
      category: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "breakfast",
          "lunch",
          "dinner",
          "snack",
          "dessert",
          "drink",
          "other",
        ] as const),
        undefined,
      ]),
      ingredients: faker.helpers.arrayElement([
        Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          id: faker.helpers.arrayElement([faker.string.uuid(), undefined]),
          recipeId: faker.helpers.arrayElement([
            faker.string.uuid(),
            undefined,
          ]),
          productId: faker.string.uuid(),
          productName: faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            undefined,
          ]),
          quantity: faker.number.float({
            min: undefined,
            max: undefined,
            fractionDigits: 2,
          }),
          unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
          kcal: faker.helpers.arrayElement([
            faker.number.int({ min: undefined, max: undefined }),
            undefined,
          ]),
          protein: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          fat: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          carbs: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          notes: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.string.alpha({ length: { min: 10, max: 20 } }),
              null,
            ]),
            undefined,
          ]),
        })),
        undefined,
      ]),
      totalKcal: faker.helpers.arrayElement([
        faker.number.int({ min: 0, max: undefined }),
        undefined,
      ]),
      totalProtein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      totalFat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      totalCarbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      kcalPerServing: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      proteinPerServing: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fatPerServing: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbsPerServing: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      imageUrl: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
      cookingTime: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          null,
        ]),
        undefined,
      ]),
      usageCount: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      lastUsedAt: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          `${faker.date.past().toISOString().split(".")[0]}Z`,
          null,
        ]),
        undefined,
      ]),
      isPublic: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    })),
    undefined,
  ]),
  total: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostRecipesResponseMock = (
  overrideResponse: Partial<Recipe> = {},
): Recipe => ({
  id: faker.string.uuid(),
  userId: faker.string.uuid(),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  description: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  servings: faker.number.int({ min: 1, max: undefined }),
  category: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      "breakfast",
      "lunch",
      "dinner",
      "snack",
      "dessert",
      "drink",
      "other",
    ] as const),
    undefined,
  ]),
  ingredients: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.helpers.arrayElement([faker.string.uuid(), undefined]),
      recipeId: faker.helpers.arrayElement([faker.string.uuid(), undefined]),
      productId: faker.string.uuid(),
      productName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      quantity: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
      kcal: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      notes: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalKcal: faker.helpers.arrayElement([
    faker.number.int({ min: 0, max: undefined }),
    undefined,
  ]),
  totalProtein: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  totalFat: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  totalCarbs: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  kcalPerServing: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  proteinPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fatPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  carbsPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  imageUrl: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  cookingTime: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      null,
    ]),
    undefined,
  ]),
  usageCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  lastUsedAt: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      null,
    ]),
    undefined,
  ]),
  isPublic: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  ...overrideResponse,
});

export const getGetRecipesIdResponseMock = (
  overrideResponse: Partial<Recipe> = {},
): Recipe => ({
  id: faker.string.uuid(),
  userId: faker.string.uuid(),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  description: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  servings: faker.number.int({ min: 1, max: undefined }),
  category: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      "breakfast",
      "lunch",
      "dinner",
      "snack",
      "dessert",
      "drink",
      "other",
    ] as const),
    undefined,
  ]),
  ingredients: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.helpers.arrayElement([faker.string.uuid(), undefined]),
      recipeId: faker.helpers.arrayElement([faker.string.uuid(), undefined]),
      productId: faker.string.uuid(),
      productName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      quantity: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
      kcal: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      notes: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalKcal: faker.helpers.arrayElement([
    faker.number.int({ min: 0, max: undefined }),
    undefined,
  ]),
  totalProtein: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  totalFat: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  totalCarbs: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  kcalPerServing: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  proteinPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fatPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  carbsPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  imageUrl: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  cookingTime: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      null,
    ]),
    undefined,
  ]),
  usageCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  lastUsedAt: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      null,
    ]),
    undefined,
  ]),
  isPublic: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  ...overrideResponse,
});

export const getPutRecipesIdResponseMock = (
  overrideResponse: Partial<Recipe> = {},
): Recipe => ({
  id: faker.string.uuid(),
  userId: faker.string.uuid(),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  description: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  servings: faker.number.int({ min: 1, max: undefined }),
  category: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      "breakfast",
      "lunch",
      "dinner",
      "snack",
      "dessert",
      "drink",
      "other",
    ] as const),
    undefined,
  ]),
  ingredients: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.helpers.arrayElement([faker.string.uuid(), undefined]),
      recipeId: faker.helpers.arrayElement([faker.string.uuid(), undefined]),
      productId: faker.string.uuid(),
      productName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      quantity: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
      kcal: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      notes: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalKcal: faker.helpers.arrayElement([
    faker.number.int({ min: 0, max: undefined }),
    undefined,
  ]),
  totalProtein: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  totalFat: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  totalCarbs: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  kcalPerServing: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  proteinPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fatPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  carbsPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  imageUrl: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  cookingTime: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      null,
    ]),
    undefined,
  ]),
  usageCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  lastUsedAt: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      null,
    ]),
    undefined,
  ]),
  isPublic: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  ...overrideResponse,
});

export const getPostRecipesIdDuplicateResponseMock = (
  overrideResponse: Partial<Recipe> = {},
): Recipe => ({
  id: faker.string.uuid(),
  userId: faker.string.uuid(),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  description: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  servings: faker.number.int({ min: 1, max: undefined }),
  category: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      "breakfast",
      "lunch",
      "dinner",
      "snack",
      "dessert",
      "drink",
      "other",
    ] as const),
    undefined,
  ]),
  ingredients: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.helpers.arrayElement([faker.string.uuid(), undefined]),
      recipeId: faker.helpers.arrayElement([faker.string.uuid(), undefined]),
      productId: faker.string.uuid(),
      productName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      quantity: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
      kcal: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      notes: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalKcal: faker.helpers.arrayElement([
    faker.number.int({ min: 0, max: undefined }),
    undefined,
  ]),
  totalProtein: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  totalFat: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  totalCarbs: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  kcalPerServing: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  proteinPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  fatPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  carbsPerServing: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  imageUrl: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  cookingTime: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      null,
    ]),
    undefined,
  ]),
  usageCount: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  lastUsedAt: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      null,
    ]),
    undefined,
  ]),
  isPublic: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  ...overrideResponse,
});

export const getPostRecipesIdAddToMealResponseMock = (
  overrideResponse: Partial<Meal> = {},
): Meal => ({
  id: faker.string.uuid(),
  dayEntryId: faker.string.uuid(),
  type: faker.helpers.arrayElement([
    "breakfast",
    "lunch",
    "dinner",
    "snack",
    "other",
  ] as const),
  time: faker.helpers.arrayElement([
    faker.helpers.fromRegExp("^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$"),
    undefined,
  ]),
  name: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  items: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      mealId: faker.string.uuid(),
      productId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      recipeId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      quantity: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
      kcal: faker.number.int({ min: 0, max: undefined }),
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      source: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalKcal: faker.number.int({ min: 0, max: undefined }),
  source: faker.helpers.arrayElement(["manual", "ai"] as const),
  aiConfidence: faker.helpers.arrayElement([
    faker.number.float({ min: 0, max: 1, fractionDigits: 2 }),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  ...overrideResponse,
});

export const getGetRecipesPublicResponseMock = (
  overrideResponse: Partial<GetRecipesPublic200> = {},
): GetRecipesPublic200 => ({
  recipes: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      userId: faker.string.uuid(),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      description: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      servings: faker.number.int({ min: 1, max: undefined }),
      category: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "breakfast",
          "lunch",
          "dinner",
          "snack",
          "dessert",
          "drink",
          "other",
        ] as const),
        undefined,
      ]),
      ingredients: faker.helpers.arrayElement([
        Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          id: faker.helpers.arrayElement([faker.string.uuid(), undefined]),
          recipeId: faker.helpers.arrayElement([
            faker.string.uuid(),
            undefined,
          ]),
          productId: faker.string.uuid(),
          productName: faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            undefined,
          ]),
          quantity: faker.number.float({
            min: undefined,
            max: undefined,
            fractionDigits: 2,
          }),
          unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
          kcal: faker.helpers.arrayElement([
            faker.number.int({ min: undefined, max: undefined }),
            undefined,
          ]),
          protein: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          fat: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          carbs: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          notes: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.string.alpha({ length: { min: 10, max: 20 } }),
              null,
            ]),
            undefined,
          ]),
        })),
        undefined,
      ]),
      totalKcal: faker.helpers.arrayElement([
        faker.number.int({ min: 0, max: undefined }),
        undefined,
      ]),
      totalProtein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      totalFat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      totalCarbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      kcalPerServing: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      proteinPerServing: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fatPerServing: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbsPerServing: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      imageUrl: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        undefined,
      ]),
      cookingTime: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          null,
        ]),
        undefined,
      ]),
      usageCount: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      lastUsedAt: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          `${faker.date.past().toISOString().split(".")[0]}Z`,
          null,
        ]),
        undefined,
      ]),
      isPublic: faker.helpers.arrayElement([
        faker.datatype.boolean(),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetPlansResponseMock = (
  overrideResponse: Partial<GetPlans200> = {},
): GetPlans200 => ({
  plans: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      userId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      targetKcal: faker.number.int({ min: 0, max: undefined }),
      macros: faker.helpers.arrayElement([
        {
          proteinPct: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          fatPct: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          carbsPct: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
        },
        undefined,
      ]),
      description: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostPlansIdApplyResponseMock = (
  overrideResponse: Partial<PostPlansIdApply200> = {},
): PostPlansIdApply200 => ({
  message: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  appliedTo: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetStatsResponseMock = (
  overrideResponse: Partial<StatsResponse> = {},
): StatsResponse => ({
  period: faker.helpers.arrayElement([
    {
      from: faker.helpers.arrayElement([
        faker.date.past().toISOString().split("T")[0],
        undefined,
      ]),
      to: faker.helpers.arrayElement([
        faker.date.past().toISOString().split("T")[0],
        undefined,
      ]),
    },
    undefined,
  ]),
  averageKcal: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  totalKcal: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  daysTracked: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  averageMacros: faker.helpers.arrayElement([
    {
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
    },
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostAuthSignupMockHandler = (
  overrideResponse?:
    | AuthResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<AuthResponse> | AuthResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/auth/signup",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostAuthSignupResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostAuthLoginMockHandler = (
  overrideResponse?:
    | AuthResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<AuthResponse> | AuthResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/auth/login",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostAuthLoginResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostAuthGoogleMockHandler = (
  overrideResponse?:
    | AuthResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<AuthResponse> | AuthResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/auth/google",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostAuthGoogleResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetCalendarMockHandler = (
  overrideResponse?:
    | GetCalendar200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetCalendar200> | GetCalendar200),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/calendar",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetCalendarResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetDayDateMockHandler = (
  overrideResponse?:
    | DayEntry
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<DayEntry> | DayEntry),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/day/:date",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetDayDateResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostDayDateMealsMockHandler = (
  overrideResponse?:
    | Meal
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Meal> | Meal),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/day/:date/meals",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostDayDateMealsResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPutMealsIdMockHandler = (
  overrideResponse?:
    | Meal
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<Meal> | Meal),
  options?: RequestHandlerOptions,
) => {
  return http.put(
    "*/meals/:id",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPutMealsIdResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getDeleteMealsIdMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
      ) => Promise<void> | void),
  options?: RequestHandlerOptions,
) => {
  return http.delete(
    "*/meals/:id",
    async (info) => {
      await delay(1000);
      if (typeof overrideResponse === "function") {
        await overrideResponse(info);
      }
      return new HttpResponse(null, { status: 204 });
    },
    options,
  );
};

export const getPostAiParseMealMockHandler = (
  overrideResponse?:
    | AiParseMealResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<AiParseMealResponse> | AiParseMealResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/ai/parse-meal",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostAiParseMealResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetProductsMockHandler = (
  overrideResponse?:
    | GetProducts200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetProducts200> | GetProducts200),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/products",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetProductsResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostProductsMockHandler = (
  overrideResponse?:
    | Product
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Product> | Product),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/products",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostProductsResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetProductsSearchMockHandler = (
  overrideResponse?:
    | GetProductsSearch200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetProductsSearch200> | GetProductsSearch200),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/products/search",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetProductsSearchResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetProductsIdMockHandler = (
  overrideResponse?:
    | Product
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<Product> | Product),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/products/:id",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetProductsIdResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPutProductsIdMockHandler = (
  overrideResponse?:
    | Product
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<Product> | Product),
  options?: RequestHandlerOptions,
) => {
  return http.put(
    "*/products/:id",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPutProductsIdResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getDeleteProductsIdMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
      ) => Promise<void> | void),
  options?: RequestHandlerOptions,
) => {
  return http.delete(
    "*/products/:id",
    async (info) => {
      await delay(1000);
      if (typeof overrideResponse === "function") {
        await overrideResponse(info);
      }
      return new HttpResponse(null, { status: 204 });
    },
    options,
  );
};

export const getGetProductsBarcodeBarcodeMockHandler = (
  overrideResponse?:
    | Product
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<Product> | Product),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/products/barcode/:barcode",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetProductsBarcodeBarcodeResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetRecipesMockHandler = (
  overrideResponse?:
    | GetRecipes200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetRecipes200> | GetRecipes200),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/recipes",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetRecipesResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostRecipesMockHandler = (
  overrideResponse?:
    | Recipe
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Recipe> | Recipe),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/recipes",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostRecipesResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetRecipesIdMockHandler = (
  overrideResponse?:
    | Recipe
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<Recipe> | Recipe),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/recipes/:id",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetRecipesIdResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPutRecipesIdMockHandler = (
  overrideResponse?:
    | Recipe
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<Recipe> | Recipe),
  options?: RequestHandlerOptions,
) => {
  return http.put(
    "*/recipes/:id",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPutRecipesIdResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getDeleteRecipesIdMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
      ) => Promise<void> | void),
  options?: RequestHandlerOptions,
) => {
  return http.delete(
    "*/recipes/:id",
    async (info) => {
      await delay(1000);
      if (typeof overrideResponse === "function") {
        await overrideResponse(info);
      }
      return new HttpResponse(null, { status: 204 });
    },
    options,
  );
};

export const getPostRecipesIdDuplicateMockHandler = (
  overrideResponse?:
    | Recipe
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Recipe> | Recipe),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/recipes/:id/duplicate",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostRecipesIdDuplicateResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostRecipesIdAddToMealMockHandler = (
  overrideResponse?:
    | Meal
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Meal> | Meal),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/recipes/:id/add-to-meal",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostRecipesIdAddToMealResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetRecipesPublicMockHandler = (
  overrideResponse?:
    | GetRecipesPublic200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetRecipesPublic200> | GetRecipesPublic200),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/recipes/public",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetRecipesPublicResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetPlansMockHandler = (
  overrideResponse?:
    | GetPlans200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetPlans200> | GetPlans200),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/plans",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetPlansResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostPlansIdApplyMockHandler = (
  overrideResponse?:
    | PostPlansIdApply200
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<PostPlansIdApply200> | PostPlansIdApply200),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/plans/:id/apply",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostPlansIdApplyResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetStatsMockHandler = (
  overrideResponse?:
    | StatsResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<StatsResponse> | StatsResponse),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/stats",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetStatsResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};
export const getNutriAIFoodCalorieTrackerAPIMock = () => [
  getPostAuthSignupMockHandler(),
  getPostAuthLoginMockHandler(),
  getPostAuthGoogleMockHandler(),
  getGetCalendarMockHandler(),
  getGetDayDateMockHandler(),
  getPostDayDateMealsMockHandler(),
  getPutMealsIdMockHandler(),
  getDeleteMealsIdMockHandler(),
  getPostAiParseMealMockHandler(),
  getGetProductsMockHandler(),
  getPostProductsMockHandler(),
  getGetProductsSearchMockHandler(),
  getGetProductsIdMockHandler(),
  getPutProductsIdMockHandler(),
  getDeleteProductsIdMockHandler(),
  getGetProductsBarcodeBarcodeMockHandler(),
  getGetRecipesMockHandler(),
  getPostRecipesMockHandler(),
  getGetRecipesIdMockHandler(),
  getPutRecipesIdMockHandler(),
  getDeleteRecipesIdMockHandler(),
  getPostRecipesIdDuplicateMockHandler(),
  getPostRecipesIdAddToMealMockHandler(),
  getGetRecipesPublicMockHandler(),
  getGetPlansMockHandler(),
  getPostPlansIdApplyMockHandler(),
  getGetStatsMockHandler(),
];
