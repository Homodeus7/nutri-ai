/**
 * Generated by orval v7.14.0 üç∫
 * Do not edit manually.
 * Nutri AI Food Calorie Tracker API
 * API –¥–ª—è —É—á—ë—Ç–∞ –∏ –ø–æ–¥—Å—á—ë—Ç–∞ –∫–∞–ª–æ—Ä–∏–π —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –≤–≤–æ–¥–∞ –ø—Ä–∏—ë–º–∞ –ø–∏—â–∏ —á–µ—Ä–µ–∑ –ò–ò
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import { faker } from "@faker-js/faker";

import { HttpResponse, delay, http } from "msw";
import type { RequestHandlerOptions } from "msw";

import { createInstance } from "../api-instance";
import type { ErrorType, BodyType } from "../api-instance";
export interface User {
  id: string;
  email: string;
  passwordHash: string;
  displayName?: string;
  timezone?: string;
  /** @minimum 0 */
  dailyKcalGoal?: number;
  createdAt: string;
}

export interface DayEntry {
  id: string;
  userId: string;
  date: string;
  /** @minimum 0 */
  targetKcal?: number;
  /** @minimum 0 */
  consumedKcal?: number;
  notes?: string;
  createdAt: string;
  updatedAt: string;
  meals?: Meal[];
}

export type MealType = (typeof MealType)[keyof typeof MealType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MealType = {
  breakfast: "breakfast",
  lunch: "lunch",
  dinner: "dinner",
  snack: "snack",
  other: "other",
} as const;

export type MealSource = (typeof MealSource)[keyof typeof MealSource];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MealSource = {
  manual: "manual",
  ai: "ai",
} as const;

export interface Meal {
  id: string;
  dayEntryId: string;
  type: MealType;
  /** @pattern ^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$ */
  time?: string;
  name?: string;
  items?: FoodItem[];
  /** @minimum 0 */
  totalKcal: number;
  source: MealSource;
  /**
   * @minimum 0
   * @maximum 1
   */
  aiConfidence?: number;
  createdAt: string;
  updatedAt: string;
}

export interface FoodItem {
  id: string;
  mealId: string;
  name: string;
  quantity: number;
  unit: string;
  /** @minimum 0 */
  kcal: number;
  protein?: number;
  fat?: number;
  carbs?: number;
  source?: string;
}

export type DietPlanMacros = {
  proteinPct?: number;
  fatPct?: number;
  carbsPct?: number;
};

export interface DietPlan {
  id: string;
  /** @nullable */
  userId?: string | null;
  name: string;
  /** @minimum 0 */
  targetKcal: number;
  macros?: DietPlanMacros;
  description?: string;
  createdAt: string;
  updatedAt: string;
}

export type AiParseLogRequestPayload = { [key: string]: unknown };

export type AiParseLogResponsePayload = { [key: string]: unknown };

export interface AiParseLog {
  id: string;
  /** @nullable */
  userId?: string | null;
  requestText: string;
  requestPayload?: AiParseLogRequestPayload;
  responsePayload?: AiParseLogResponsePayload;
  responseTimeMs?: number;
  createdAt: string;
}

export interface CalendarDay {
  date: string;
  /** @minimum 0 */
  consumedKcal: number;
  /** @minimum 0 */
  targetKcal: number;
  /**
   * @minimum 0
   * @maximum 100
   */
  consumedPercent: number;
}

export interface SignupRequest {
  email: string;
  /** @minLength 8 */
  password: string;
  displayName?: string;
  timezone?: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface GoogleAuthRequest {
  /** Google ID token from Gmail OAuth */
  idToken: string;
}

export interface AuthResponse {
  token?: string;
  user?: User;
}

export type CreateMealRequestType =
  (typeof CreateMealRequestType)[keyof typeof CreateMealRequestType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateMealRequestType = {
  breakfast: "breakfast",
  lunch: "lunch",
  dinner: "dinner",
  snack: "snack",
  other: "other",
} as const;

export type CreateMealRequestItemsItem = {
  name: string;
  quantity: number;
  unit: string;
  kcal: number;
  protein?: number;
  fat?: number;
  carbs?: number;
  source?: string;
};

export type CreateMealRequestSource =
  (typeof CreateMealRequestSource)[keyof typeof CreateMealRequestSource];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateMealRequestSource = {
  manual: "manual",
  ai: "ai",
} as const;

export interface CreateMealRequest {
  type: CreateMealRequestType;
  /** @pattern ^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$ */
  time?: string;
  name?: string;
  items?: CreateMealRequestItemsItem[];
  /** @minimum 0 */
  totalKcal: number;
  source: CreateMealRequestSource;
  /**
   * @minimum 0
   * @maximum 1
   */
  aiConfidence?: number;
}

export interface AiParseMealRequest {
  userId?: string;
  date?: string;
  /** @maxLength 2048 */
  text: string;
}

export type AiParseMealResponseParsedItemsItem = {
  name?: string;
  quantity?: number;
  unit?: string;
  kcal?: number;
  protein?: number;
  fat?: number;
  carbs?: number;
  /**
   * @minimum 0
   * @maximum 1
   */
  confidence?: number;
};

export interface AiParseMealResponse {
  parsedItems?: AiParseMealResponseParsedItemsItem[];
  /** @minimum 0 */
  totalKcal?: number;
  warnings?: string[];
}

export interface StatsResponse {
  from?: string;
  to?: string;
  totalKcal?: number;
  averageKcal?: number;
  averageGoalCompletion?: number;
  days?: CalendarDay[];
}

export type ErrorDetails = { [key: string]: unknown };

export interface Error {
  error?: string;
  message?: string;
  details?: ErrorDetails;
}

/**
 * –ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω
 */
export type UnauthorizedResponse = Error;

/**
 * –ù–µ –Ω–∞–π–¥–µ–Ω–æ
 */
export type NotFoundResponse = Error;

/**
 * –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å
 */
export type BadRequestResponse = Error;

export type GetCalendarParams = {
  /**
   * @pattern ^\d{4}-\d{2}$
   */
  month: string;
};

export type GetCalendar200 = {
  month?: string;
  days?: CalendarDay[];
};

export type GetPlans200 = {
  plans?: DietPlan[];
};

export type PostPlansIdApplyParams = {
  date?: string;
};

export type PostPlansIdApply200 = {
  message?: string;
  appliedTo?: string;
};

export type GetStatsParams = {
  from: string;
  to: string;
};

/**
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const postAuthSignup = (
  signupRequest: BodyType<SignupRequest>,
  signal?: AbortSignal,
) => {
  return createInstance<AuthResponse>({
    url: `/auth/signup`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: signupRequest,
    signal,
  });
};

export const getPostAuthSignupMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthSignup>>,
    TError,
    { data: BodyType<SignupRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthSignup>>,
  TError,
  { data: BodyType<SignupRequest> },
  TContext
> => {
  const mutationKey = ["postAuthSignup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthSignup>>,
    { data: BodyType<SignupRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthSignup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthSignup>>
>;
export type PostAuthSignupMutationBody = BodyType<SignupRequest>;
export type PostAuthSignupMutationError = ErrorType<Error>;

/**
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const usePostAuthSignup = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthSignup>>,
      TError,
      { data: BodyType<SignupRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthSignup>>,
  TError,
  { data: BodyType<SignupRequest> },
  TContext
> => {
  const mutationOptions = getPostAuthSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –í—Ö–æ–¥ —Å email –∏ –ø–∞—Ä–æ–ª–µ–º
 */
export const postAuthLogin = (
  loginRequest: BodyType<LoginRequest>,
  signal?: AbortSignal,
) => {
  return createInstance<AuthResponse>({
    url: `/auth/login`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: loginRequest,
    signal,
  });
};

export const getPostAuthLoginMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthLogin>>,
    TError,
    { data: BodyType<LoginRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthLogin>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationKey = ["postAuthLogin"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthLogin>>,
    { data: BodyType<LoginRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthLogin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthLogin>>
>;
export type PostAuthLoginMutationBody = BodyType<LoginRequest>;
export type PostAuthLoginMutationError = ErrorType<Error>;

/**
 * @summary –í—Ö–æ–¥ —Å email –∏ –ø–∞—Ä–æ–ª–µ–º
 */
export const usePostAuthLogin = <TError = ErrorType<Error>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthLogin>>,
      TError,
      { data: BodyType<LoginRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthLogin>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationOptions = getPostAuthLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —á–µ—Ä–µ–∑ Google OAuth ID token
 * @summary –í—Ö–æ–¥ —á–µ—Ä–µ–∑ Google (Gmail)
 */
export const postAuthGoogle = (
  googleAuthRequest: BodyType<GoogleAuthRequest>,
  signal?: AbortSignal,
) => {
  return createInstance<AuthResponse>({
    url: `/auth/google`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: googleAuthRequest,
    signal,
  });
};

export const getPostAuthGoogleMutationOptions = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthGoogle>>,
    TError,
    { data: BodyType<GoogleAuthRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthGoogle>>,
  TError,
  { data: BodyType<GoogleAuthRequest> },
  TContext
> => {
  const mutationKey = ["postAuthGoogle"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthGoogle>>,
    { data: BodyType<GoogleAuthRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthGoogle(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthGoogleMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthGoogle>>
>;
export type PostAuthGoogleMutationBody = BodyType<GoogleAuthRequest>;
export type PostAuthGoogleMutationError = ErrorType<Error>;

/**
 * @summary –í—Ö–æ–¥ —á–µ—Ä–µ–∑ Google (Gmail)
 */
export const usePostAuthGoogle = <
  TError = ErrorType<Error>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthGoogle>>,
      TError,
      { data: BodyType<GoogleAuthRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthGoogle>>,
  TError,
  { data: BodyType<GoogleAuthRequest> },
  TContext
> => {
  const mutationOptions = getPostAuthGoogleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞–ª–µ–Ω–¥–∞—Ä—å –∑–∞ –º–µ—Å—è—Ü
 */
export const getCalendar = (
  params: GetCalendarParams,
  signal?: AbortSignal,
) => {
  return createInstance<GetCalendar200>({
    url: `/calendar`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetCalendarQueryKey = (params?: GetCalendarParams) => {
  return [`/calendar`, ...(params ? [params] : [])] as const;
};

export const getGetCalendarQueryOptions = <
  TData = Awaited<ReturnType<typeof getCalendar>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetCalendarParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCalendar>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCalendarQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCalendar>>> = ({
    signal,
  }) => getCalendar(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCalendar>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCalendarQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCalendar>>
>;
export type GetCalendarQueryError = ErrorType<UnauthorizedResponse>;

export function useGetCalendar<
  TData = Awaited<ReturnType<typeof getCalendar>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetCalendarParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCalendar>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCalendar>>,
          TError,
          Awaited<ReturnType<typeof getCalendar>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCalendar<
  TData = Awaited<ReturnType<typeof getCalendar>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetCalendarParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCalendar>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCalendar>>,
          TError,
          Awaited<ReturnType<typeof getCalendar>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCalendar<
  TData = Awaited<ReturnType<typeof getCalendar>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetCalendarParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCalendar>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞–ª–µ–Ω–¥–∞—Ä—å –∑–∞ –º–µ—Å—è—Ü
 */

export function useGetCalendar<
  TData = Awaited<ReturnType<typeof getCalendar>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  params: GetCalendarParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCalendar>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCalendarQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∑–∞ –¥–µ–Ω—å
 */
export const getDayDate = (date: string, signal?: AbortSignal) => {
  return createInstance<DayEntry>({
    url: `/day/${date}`,
    method: "GET",
    signal,
  });
};

export const getGetDayDateQueryKey = (date?: string) => {
  return [`/day/${date}`] as const;
};

export const getGetDayDateQueryOptions = <
  TData = Awaited<ReturnType<typeof getDayDate>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDayDate>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDayDateQueryKey(date);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDayDate>>> = ({
    signal,
  }) => getDayDate(date, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!date,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDayDate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDayDateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDayDate>>
>;
export type GetDayDateQueryError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

export function useGetDayDate<
  TData = Awaited<ReturnType<typeof getDayDate>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  date: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDayDate>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDayDate>>,
          TError,
          Awaited<ReturnType<typeof getDayDate>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDayDate<
  TData = Awaited<ReturnType<typeof getDayDate>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDayDate>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDayDate>>,
          TError,
          Awaited<ReturnType<typeof getDayDate>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDayDate<
  TData = Awaited<ReturnType<typeof getDayDate>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDayDate>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∑–∞ –¥–µ–Ω—å
 */

export function useGetDayDate<
  TData = Awaited<ReturnType<typeof getDayDate>>,
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDayDate>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDayDateQueryOptions(date, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –°–æ–∑–¥–∞—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const postDayDateMeals = (
  date: string,
  createMealRequest: BodyType<CreateMealRequest>,
  signal?: AbortSignal,
) => {
  return createInstance<Meal>({
    url: `/day/${date}/meals`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createMealRequest,
    signal,
  });
};

export const getPostDayDateMealsMutationOptions = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postDayDateMeals>>,
    TError,
    { date: string; data: BodyType<CreateMealRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postDayDateMeals>>,
  TError,
  { date: string; data: BodyType<CreateMealRequest> },
  TContext
> => {
  const mutationKey = ["postDayDateMeals"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postDayDateMeals>>,
    { date: string; data: BodyType<CreateMealRequest> }
  > = (props) => {
    const { date, data } = props ?? {};

    return postDayDateMeals(date, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostDayDateMealsMutationResult = NonNullable<
  Awaited<ReturnType<typeof postDayDateMeals>>
>;
export type PostDayDateMealsMutationBody = BodyType<CreateMealRequest>;
export type PostDayDateMealsMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse
>;

/**
 * @summary –°–æ–∑–¥–∞—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const usePostDayDateMeals = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postDayDateMeals>>,
      TError,
      { date: string; data: BodyType<CreateMealRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postDayDateMeals>>,
  TError,
  { date: string; data: BodyType<CreateMealRequest> },
  TContext
> => {
  const mutationOptions = getPostDayDateMealsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const putMealsId = (
  id: string,
  createMealRequest: BodyType<CreateMealRequest>,
) => {
  return createInstance<Meal>({
    url: `/meals/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: createMealRequest,
  });
};

export const getPutMealsIdMutationOptions = <
  TError = ErrorType<
    BadRequestResponse | UnauthorizedResponse | NotFoundResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putMealsId>>,
    TError,
    { id: string; data: BodyType<CreateMealRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putMealsId>>,
  TError,
  { id: string; data: BodyType<CreateMealRequest> },
  TContext
> => {
  const mutationKey = ["putMealsId"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putMealsId>>,
    { id: string; data: BodyType<CreateMealRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return putMealsId(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutMealsIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof putMealsId>>
>;
export type PutMealsIdMutationBody = BodyType<CreateMealRequest>;
export type PutMealsIdMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const usePutMealsId = <
  TError = ErrorType<
    BadRequestResponse | UnauthorizedResponse | NotFoundResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putMealsId>>,
      TError,
      { id: string; data: BodyType<CreateMealRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putMealsId>>,
  TError,
  { id: string; data: BodyType<CreateMealRequest> },
  TContext
> => {
  const mutationOptions = getPutMealsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const deleteMealsId = (id: string) => {
  return createInstance<void>({ url: `/meals/${id}`, method: "DELETE" });
};

export const getDeleteMealsIdMutationOptions = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMealsId>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMealsId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteMealsId"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMealsId>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteMealsId(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteMealsIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMealsId>>
>;

export type DeleteMealsIdMutationError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø—Ä–∏—ë–º –ø–∏—â–∏
 */
export const useDeleteMealsId = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMealsId>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMealsId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteMealsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –†–∞—Å–ø–∞—Ä—Å–∏—Ç—å —Ç–µ–∫—Å—Ç —á–µ—Ä–µ–∑ AI
 */
export const postAiParseMeal = (
  aiParseMealRequest: BodyType<AiParseMealRequest>,
  signal?: AbortSignal,
) => {
  return createInstance<AiParseMealResponse>({
    url: `/ai/parse-meal`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: aiParseMealRequest,
    signal,
  });
};

export const getPostAiParseMealMutationOptions = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse | Error>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAiParseMeal>>,
    TError,
    { data: BodyType<AiParseMealRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAiParseMeal>>,
  TError,
  { data: BodyType<AiParseMealRequest> },
  TContext
> => {
  const mutationKey = ["postAiParseMeal"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAiParseMeal>>,
    { data: BodyType<AiParseMealRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return postAiParseMeal(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAiParseMealMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAiParseMeal>>
>;
export type PostAiParseMealMutationBody = BodyType<AiParseMealRequest>;
export type PostAiParseMealMutationError = ErrorType<
  BadRequestResponse | UnauthorizedResponse | Error
>;

/**
 * @summary –†–∞—Å–ø–∞—Ä—Å–∏—Ç—å —Ç–µ–∫—Å—Ç —á–µ—Ä–µ–∑ AI
 */
export const usePostAiParseMeal = <
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse | Error>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAiParseMeal>>,
      TError,
      { data: BodyType<AiParseMealRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAiParseMeal>>,
  TError,
  { data: BodyType<AiParseMealRequest> },
  TContext
> => {
  const mutationOptions = getPostAiParseMealMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–ª–∞–Ω–æ–≤
 */
export const getPlans = (signal?: AbortSignal) => {
  return createInstance<GetPlans200>({ url: `/plans`, method: "GET", signal });
};

export const getGetPlansQueryKey = () => {
  return [`/plans`] as const;
};

export const getGetPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = ErrorType<UnauthorizedResponse>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPlansQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlans>>> = ({
    signal,
  }) => getPlans(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPlans>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlans>>
>;
export type GetPlansQueryError = ErrorType<UnauthorizedResponse>;

export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlans>>,
          TError,
          Awaited<ReturnType<typeof getPlans>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlans>>,
          TError,
          Awaited<ReturnType<typeof getPlans>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–ª–∞–Ω–æ–≤
 */

export function useGetPlans<
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = ErrorType<UnauthorizedResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPlansQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary –ü—Ä–∏–º–µ–Ω–∏—Ç—å –ø–ª–∞–Ω
 */
export const postPlansIdApply = (
  id: string,
  params?: PostPlansIdApplyParams,
  signal?: AbortSignal,
) => {
  return createInstance<PostPlansIdApply200>({
    url: `/plans/${id}/apply`,
    method: "POST",
    params,
    signal,
  });
};

export const getPostPlansIdApplyMutationOptions = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postPlansIdApply>>,
    TError,
    { id: string; params?: PostPlansIdApplyParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postPlansIdApply>>,
  TError,
  { id: string; params?: PostPlansIdApplyParams },
  TContext
> => {
  const mutationKey = ["postPlansIdApply"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPlansIdApply>>,
    { id: string; params?: PostPlansIdApplyParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return postPlansIdApply(id, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPlansIdApplyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPlansIdApply>>
>;

export type PostPlansIdApplyMutationError = ErrorType<
  UnauthorizedResponse | NotFoundResponse
>;

/**
 * @summary –ü—Ä–∏–º–µ–Ω–∏—Ç—å –ø–ª–∞–Ω
 */
export const usePostPlansIdApply = <
  TError = ErrorType<UnauthorizedResponse | NotFoundResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postPlansIdApply>>,
      TError,
      { id: string; params?: PostPlansIdApplyParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postPlansIdApply>>,
  TError,
  { id: string; params?: PostPlansIdApplyParams },
  TContext
> => {
  const mutationOptions = getPostPlansIdApplyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–µ—Ä–∏–æ–¥
 */
export const getStats = (params: GetStatsParams, signal?: AbortSignal) => {
  return createInstance<StatsResponse>({
    url: `/stats`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetStatsQueryKey = (params?: GetStatsParams) => {
  return [`/stats`, ...(params ? [params] : [])] as const;
};

export const getGetStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof getStats>>,
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
>(
  params: GetStatsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStatsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStats>>> = ({
    signal,
  }) => getStats(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStats>>
>;
export type GetStatsQueryError = ErrorType<
  BadRequestResponse | UnauthorizedResponse
>;

export function useGetStats<
  TData = Awaited<ReturnType<typeof getStats>>,
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
>(
  params: GetStatsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStats>>,
          TError,
          Awaited<ReturnType<typeof getStats>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStats<
  TData = Awaited<ReturnType<typeof getStats>>,
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
>(
  params: GetStatsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStats>>,
          TError,
          Awaited<ReturnType<typeof getStats>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStats<
  TData = Awaited<ReturnType<typeof getStats>>,
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
>(
  params: GetStatsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–µ—Ä–∏–æ–¥
 */

export function useGetStats<
  TData = Awaited<ReturnType<typeof getStats>>,
  TError = ErrorType<BadRequestResponse | UnauthorizedResponse>,
>(
  params: GetStatsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStats>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetStatsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPostAuthSignupResponseMock = (
  overrideResponse: Partial<AuthResponse> = {},
): AuthResponse => ({
  token: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  user: faker.helpers.arrayElement([
    {
      id: faker.string.uuid(),
      email: faker.internet.email(),
      passwordHash: faker.string.alpha({ length: { min: 10, max: 20 } }),
      displayName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      timezone: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      dailyKcalGoal: faker.helpers.arrayElement([
        faker.number.int({ min: 0, max: undefined }),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    },
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostAuthLoginResponseMock = (
  overrideResponse: Partial<AuthResponse> = {},
): AuthResponse => ({
  token: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  user: faker.helpers.arrayElement([
    {
      id: faker.string.uuid(),
      email: faker.internet.email(),
      passwordHash: faker.string.alpha({ length: { min: 10, max: 20 } }),
      displayName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      timezone: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      dailyKcalGoal: faker.helpers.arrayElement([
        faker.number.int({ min: 0, max: undefined }),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    },
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostAuthGoogleResponseMock = (
  overrideResponse: Partial<AuthResponse> = {},
): AuthResponse => ({
  token: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  user: faker.helpers.arrayElement([
    {
      id: faker.string.uuid(),
      email: faker.internet.email(),
      passwordHash: faker.string.alpha({ length: { min: 10, max: 20 } }),
      displayName: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      timezone: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      dailyKcalGoal: faker.helpers.arrayElement([
        faker.number.int({ min: 0, max: undefined }),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    },
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetCalendarResponseMock = (
  overrideResponse: Partial<GetCalendar200> = {},
): GetCalendar200 => ({
  month: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  days: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      date: faker.date.past().toISOString().split("T")[0],
      consumedKcal: faker.number.int({ min: 0, max: undefined }),
      targetKcal: faker.number.int({ min: 0, max: undefined }),
      consumedPercent: faker.number.float({
        min: 0,
        max: 100,
        fractionDigits: 2,
      }),
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetDayDateResponseMock = (
  overrideResponse: Partial<DayEntry> = {},
): DayEntry => ({
  id: faker.string.uuid(),
  userId: faker.string.uuid(),
  date: faker.date.past().toISOString().split("T")[0],
  targetKcal: faker.helpers.arrayElement([
    faker.number.int({ min: 0, max: undefined }),
    undefined,
  ]),
  consumedKcal: faker.helpers.arrayElement([
    faker.number.int({ min: 0, max: undefined }),
    undefined,
  ]),
  notes: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  meals: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      dayEntryId: faker.string.uuid(),
      type: faker.helpers.arrayElement([
        "breakfast",
        "lunch",
        "dinner",
        "snack",
        "other",
      ] as const),
      time: faker.helpers.arrayElement([
        faker.helpers.fromRegExp("^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$"),
        undefined,
      ]),
      name: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      items: faker.helpers.arrayElement([
        Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          id: faker.string.uuid(),
          mealId: faker.string.uuid(),
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          quantity: faker.number.float({
            min: undefined,
            max: undefined,
            fractionDigits: 2,
          }),
          unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
          kcal: faker.number.int({ min: 0, max: undefined }),
          protein: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          fat: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          carbs: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          source: faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            undefined,
          ]),
        })),
        undefined,
      ]),
      totalKcal: faker.number.int({ min: 0, max: undefined }),
      source: faker.helpers.arrayElement(["manual", "ai"] as const),
      aiConfidence: faker.helpers.arrayElement([
        faker.number.float({ min: 0, max: 1, fractionDigits: 2 }),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostDayDateMealsResponseMock = (
  overrideResponse: Partial<Meal> = {},
): Meal => ({
  id: faker.string.uuid(),
  dayEntryId: faker.string.uuid(),
  type: faker.helpers.arrayElement([
    "breakfast",
    "lunch",
    "dinner",
    "snack",
    "other",
  ] as const),
  time: faker.helpers.arrayElement([
    faker.helpers.fromRegExp("^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$"),
    undefined,
  ]),
  name: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  items: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      mealId: faker.string.uuid(),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      quantity: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
      kcal: faker.number.int({ min: 0, max: undefined }),
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      source: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalKcal: faker.number.int({ min: 0, max: undefined }),
  source: faker.helpers.arrayElement(["manual", "ai"] as const),
  aiConfidence: faker.helpers.arrayElement([
    faker.number.float({ min: 0, max: 1, fractionDigits: 2 }),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  ...overrideResponse,
});

export const getPutMealsIdResponseMock = (
  overrideResponse: Partial<Meal> = {},
): Meal => ({
  id: faker.string.uuid(),
  dayEntryId: faker.string.uuid(),
  type: faker.helpers.arrayElement([
    "breakfast",
    "lunch",
    "dinner",
    "snack",
    "other",
  ] as const),
  time: faker.helpers.arrayElement([
    faker.helpers.fromRegExp("^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$"),
    undefined,
  ]),
  name: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  items: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      mealId: faker.string.uuid(),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      quantity: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      unit: faker.string.alpha({ length: { min: 10, max: 20 } }),
      kcal: faker.number.int({ min: 0, max: undefined }),
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      source: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalKcal: faker.number.int({ min: 0, max: undefined }),
  source: faker.helpers.arrayElement(["manual", "ai"] as const),
  aiConfidence: faker.helpers.arrayElement([
    faker.number.float({ min: 0, max: 1, fractionDigits: 2 }),
    undefined,
  ]),
  createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
  ...overrideResponse,
});

export const getPostAiParseMealResponseMock = (
  overrideResponse: Partial<AiParseMealResponse> = {},
): AiParseMealResponse => ({
  parsedItems: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      name: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      quantity: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      unit: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      kcal: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined,
      ]),
      protein: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      fat: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      carbs: faker.helpers.arrayElement([
        faker.number.float({
          min: undefined,
          max: undefined,
          fractionDigits: 2,
        }),
        undefined,
      ]),
      confidence: faker.helpers.arrayElement([
        faker.number.float({ min: 0, max: 1, fractionDigits: 2 }),
        undefined,
      ]),
    })),
    undefined,
  ]),
  totalKcal: faker.helpers.arrayElement([
    faker.number.int({ min: 0, max: undefined }),
    undefined,
  ]),
  warnings: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetPlansResponseMock = (
  overrideResponse: Partial<GetPlans200> = {},
): GetPlans200 => ({
  plans: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      userId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      targetKcal: faker.number.int({ min: 0, max: undefined }),
      macros: faker.helpers.arrayElement([
        {
          proteinPct: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          fatPct: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
          carbsPct: faker.helpers.arrayElement([
            faker.number.float({
              min: undefined,
              max: undefined,
              fractionDigits: 2,
            }),
            undefined,
          ]),
        },
        undefined,
      ]),
      description: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostPlansIdApplyResponseMock = (
  overrideResponse: Partial<PostPlansIdApply200> = {},
): PostPlansIdApply200 => ({
  message: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  appliedTo: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetStatsResponseMock = (
  overrideResponse: Partial<StatsResponse> = {},
): StatsResponse => ({
  from: faker.helpers.arrayElement([
    faker.date.past().toISOString().split("T")[0],
    undefined,
  ]),
  to: faker.helpers.arrayElement([
    faker.date.past().toISOString().split("T")[0],
    undefined,
  ]),
  totalKcal: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined }),
    undefined,
  ]),
  averageKcal: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  averageGoalCompletion: faker.helpers.arrayElement([
    faker.number.float({ min: undefined, max: undefined, fractionDigits: 2 }),
    undefined,
  ]),
  days: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      date: faker.date.past().toISOString().split("T")[0],
      consumedKcal: faker.number.int({ min: 0, max: undefined }),
      targetKcal: faker.number.int({ min: 0, max: undefined }),
      consumedPercent: faker.number.float({
        min: 0,
        max: 100,
        fractionDigits: 2,
      }),
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getPostAuthSignupMockHandler = (
  overrideResponse?:
    | AuthResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<AuthResponse> | AuthResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/auth/signup",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostAuthSignupResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostAuthLoginMockHandler = (
  overrideResponse?:
    | AuthResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<AuthResponse> | AuthResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/auth/login",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostAuthLoginResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostAuthGoogleMockHandler = (
  overrideResponse?:
    | AuthResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<AuthResponse> | AuthResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/auth/google",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostAuthGoogleResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetCalendarMockHandler = (
  overrideResponse?:
    | GetCalendar200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetCalendar200> | GetCalendar200),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/calendar",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetCalendarResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetDayDateMockHandler = (
  overrideResponse?:
    | DayEntry
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<DayEntry> | DayEntry),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/day/:date",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetDayDateResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostDayDateMealsMockHandler = (
  overrideResponse?:
    | Meal
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Meal> | Meal),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/day/:date/meals",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostDayDateMealsResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPutMealsIdMockHandler = (
  overrideResponse?:
    | Meal
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<Meal> | Meal),
  options?: RequestHandlerOptions,
) => {
  return http.put(
    "*/meals/:id",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPutMealsIdResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getDeleteMealsIdMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
      ) => Promise<void> | void),
  options?: RequestHandlerOptions,
) => {
  return http.delete(
    "*/meals/:id",
    async (info) => {
      await delay(1000);
      if (typeof overrideResponse === "function") {
        await overrideResponse(info);
      }
      return new HttpResponse(null, { status: 204 });
    },
    options,
  );
};

export const getPostAiParseMealMockHandler = (
  overrideResponse?:
    | AiParseMealResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<AiParseMealResponse> | AiParseMealResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/ai/parse-meal",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostAiParseMealResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetPlansMockHandler = (
  overrideResponse?:
    | GetPlans200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetPlans200> | GetPlans200),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/plans",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetPlansResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getPostPlansIdApplyMockHandler = (
  overrideResponse?:
    | PostPlansIdApply200
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<PostPlansIdApply200> | PostPlansIdApply200),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/plans/:id/apply",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getPostPlansIdApplyResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetStatsMockHandler = (
  overrideResponse?:
    | StatsResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<StatsResponse> | StatsResponse),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/stats",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetStatsResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};
export const getNutriAIFoodCalorieTrackerAPIMock = () => [
  getPostAuthSignupMockHandler(),
  getPostAuthLoginMockHandler(),
  getPostAuthGoogleMockHandler(),
  getGetCalendarMockHandler(),
  getGetDayDateMockHandler(),
  getPostDayDateMealsMockHandler(),
  getPutMealsIdMockHandler(),
  getDeleteMealsIdMockHandler(),
  getPostAiParseMealMockHandler(),
  getGetPlansMockHandler(),
  getPostPlansIdApplyMockHandler(),
  getGetStatsMockHandler(),
];
